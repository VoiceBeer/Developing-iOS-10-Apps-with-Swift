1
00:00:00,668 --> 00:00:08,807
本字幕由志愿者义务贡献，采用许可协议
知识共享 署名-非商业性使用-相同方式共享 3.0 美国

2
00:00:08,876 --> 00:00:12,210
>> Welcome to Stanford CS193P,
欢迎参加 2017 年冬季学期斯坦福

3
00:00:12,279 --> 00:00:16,114
Developing Applications for iOS, winter of 2017.
CS193P 课程，iOS 应用程序开发

4
00:00:16,183 --> 00:00:18,650
This is lecture number five?
这是第五节课？

5
00:00:18,719 --> 00:00:20,251
Is that right? The lecture number five?
对吧？这是第五节课？

6
00:00:20,320 --> 00:00:21,453
Yeah, lecture number five.
嗯看来是的，第五节课

7
00:00:22,790 --> 00:00:25,990
Today we are going to start off with a little demo,
今天我们将从新的小 demo 开始学习

8
00:00:26,059 --> 00:00:29,594
where I'm gonna take the application we worked on last
我将会使用上一次我们开发的程序

9
00:00:29,663 --> 00:00:31,763
time, and add a model to it.
并加入新的模型进去

10
00:00:31,831 --> 00:00:34,999
Cuz we have only worked on the view part of that,
因为之前我们只做了视图部分

11
00:00:35,068 --> 00:00:37,036
building that nice cool FaceView,
做出了那个漂亮的 FaceView（笑脸）

12
00:00:37,104 --> 00:00:40,305
now we are going to add a model to that MVC.
现在我们要加入一个模型到 MVC 中

13
00:00:40,374 --> 00:00:42,841
Then we're going to come back to the slides and
然后我们会回到幻灯片当中

14
00:00:42,910 --> 00:00:45,477
I'm going to do some slides on gestures.
然后会在幻灯片中讲关于手势操作

15
00:00:45,545 --> 00:00:49,013
Obviously, you want to be able to have input to your app,
很显然，你肯定想在你的 app 中有一个输入功能

16
00:00:49,082 --> 00:00:50,915
you need to know how to do multi-touch gestures,
那么你需要知道如何使用多点触控手势功能

17
00:00:50,984 --> 00:00:52,518
we'll talk all about that, and
我们将会讨论这个

18
00:00:52,586 --> 00:00:55,220
then I will go back to our FaceView application and
然后我会回到我们的 FaceView 程序

19
00:00:55,289 --> 00:00:58,957
we will add some gestures, pinching, panning, tapping.
并在其中加入一些手势功能，比如缩放，拖动等

20
00:00:59,026 --> 00:01:01,894
And finally, I will go back to the slides again and
最后，我会再次回到幻灯片

21
00:01:01,962 --> 00:01:04,062
start talking about multiple MVCs.
开始讲述关于多个 MVC 的知识

22
00:01:04,130 --> 00:01:06,364
How to build bigger applications that are made out
如何通过结合 MVC 来开发出功能更加强大

23
00:01:06,433 --> 00:01:11,837
of combining MVCs, so that's what's on tap for today.
的软件，这是我们今天要讲的内容

24
00:01:11,906 --> 00:01:17,809
So let's jump right back into this FaceIt Demo.
那么让我们回到之前开发的 FaceIt Demo 中

25
00:01:17,878 --> 00:01:21,346
And if you remember where we left off,
如果你还记得上次我们讲到哪了

26
00:01:21,414 --> 00:01:24,048
we had this nice view, it was really cool because,
我们有一个很棒的视图，因为我们可以

27
00:01:24,117 --> 00:01:28,220
in Interface Builder, we could do things like open the eyes.
在 Interface Builder 中进行操控，比如让其睁开眼睛

28
00:01:28,289 --> 00:01:31,189
We could make it really big,
还可以让笑脸变得很大

29
00:01:31,258 --> 00:01:36,261
we could make it really small, or anywhere in between.
或者变得很小，总之大小随你定

30
00:01:36,330 --> 00:01:39,297
And we could change the color, green,
我们还可以改变颜色

31
00:01:39,366 --> 00:01:41,299
something like that, so that's cool.
比如绿色之类的，很酷是吧

32
00:01:41,368 --> 00:01:44,302
And this is a nice reusable thing that's got a little
这是个漂亮的可变样的脸，有着一个小型

33
00:01:44,371 --> 00:01:46,104
public API to it.
公共接口

34
00:01:46,173 --> 00:01:48,240
These inspectable things are all public,
这些可审查（@IBInspectable）元素都是公开的

35
00:01:48,308 --> 00:01:52,110
so, we can set the mouth curvature, we can open and
所以，我们可以设置嘴巴的曲度，我们可以

36
00:01:52,178 --> 00:01:53,878
close the eyes, we can change those things, like scale.
睁开或闭上眼睛，我们可以改变比如比例那些设定

37
00:01:53,947 --> 00:01:56,882
And so, it's nice, it's this nice reusable face.
那么，这是个很棒的东西，一个可变样的脸

38
00:01:56,950 --> 00:02:01,086
And what we're going to do is make our MVC have a model.
那么接下来我们要做的，就是让我们的 MVC 有一个模型

39
00:02:01,155 --> 00:02:03,788
That model is not gonna match up exactly to what our
这个模型不会完全的符合我们

40
00:02:03,857 --> 00:02:06,324
FaceView can do, because that's the way models work.
在 FaceView 上想要的，因为这就是模型的工作方式

41
00:02:06,393 --> 00:02:09,961
Models in the world are often databases or something, their
在现实生活中，模型经常是数据库

42
00:02:10,030 --> 00:02:13,031
schema doesn't quite match what view you have around.
它们工作的方法通常和你的视图是不一致的

43
00:02:13,100 --> 00:02:15,600
So you, the job of the controller is to interpret
所以控制器的任务就是去理解

44
00:02:15,669 --> 00:02:18,870
that model for the view as best it can.
尽可能的把模型的内容转换给视图

45
00:02:18,939 --> 00:02:23,075
And interpret input from the view also to affect the model.
同时用视图的输入更新模型

46
00:02:23,143 --> 00:02:25,877
So let's go back to our controller,
我们先回到控制器

47
00:02:25,946 --> 00:02:29,647
you can see that we have no model, we also have no outlets
我们会发现既没有模型，也没有出口

48
00:02:29,716 --> 00:02:32,751
to our view here, so, let's add both of those things.
即保存视图的变量。所以我们把这两个东西加上

49
00:02:32,819 --> 00:02:37,021
I'm gonna start by adding an outlet to our FaceView, so
我们先创建到 FaceView 的出口

50
00:02:37,090 --> 00:02:40,758
remember how we do that, we got our storyboard on screen.
还记得怎么做吗？我们打开 Storyboard

51
00:02:40,827 --> 00:02:43,929
I'm gonna get them both on screen at the same time and
然后把两个界面同时显示出来

52
00:02:43,998 --> 00:02:45,664
then I'm gonna control drag.
然后按 control 再拖动

53
00:02:45,732 --> 00:02:48,333
And I'm control dragging from my FaceView to create
我从 FaceView 按 control 拖动

54
00:02:48,401 --> 00:02:49,134
an outlet to it,
来创建存储它的出口

55
00:02:49,202 --> 00:02:51,903
in exactly the same way I would control drag to a label,
和我按 control 拖动标签

56
00:02:51,972 --> 00:02:52,871
or button, or anything else, so
按钮等其他控件一样

57
00:02:52,940 --> 00:02:54,872
nothing special about the FaceView.
所以 FaceView 并没有什么特别的

58
00:02:54,941 --> 00:02:57,342
So I'm just gonna hold down control and drag in here,
所以我就按住 control 再拖过来

59
00:02:57,411 --> 00:02:59,778
and I'm gonna create an outlet,
创建的是 Outlet（出口）

60
00:02:59,846 --> 00:03:02,614
I'll call this outlet my faceView.
把它叫做 faceView

61
00:03:02,683 --> 00:03:06,184
That's a perfectly good name for it.
很适合它的名字

62
00:03:06,252 --> 00:03:10,689
Hit connect and there we go, we get this code that you're
点击 Connect 就得到了这样的代码

63
00:03:10,758 --> 00:03:16,961
quite used to here, which is this IBOutlet weak var.
我们已经见过几次 @IBOutlet weak var 这种形式了

64
00:03:17,030 --> 00:03:20,098
Now we have a connection to our view, and remember, in MVC
我们关联了视图，但你想想，MVC

65
00:03:20,167 --> 00:03:23,101
picture, the controller can have green arrows to its view,
在之前展示的图片里，控制器有到视图的绿色通道

66
00:03:23,170 --> 00:03:26,070
that's this, and it can have green arrows to its model.
指的就是这个代码。同时还有到模型的绿色通道

67
00:03:26,139 --> 00:03:28,273
So let's create a connection to the model.
所以我们接着把控制器和模型关联起来

68
00:03:28,342 --> 00:03:30,642
So what is gonna be our model of our MVC?
所以我们 MVC 的模型是什么？

69
00:03:30,711 --> 00:03:33,978
I'm actually going to drag that in, right here,
我已经写好了，所以直接拖进来

70
00:03:34,047 --> 00:03:35,647
it's called facial expression.
叫做 FacialExpression.swift

71
00:03:37,417 --> 00:03:39,851
When you drag things in I strongly recommend
当你通过拖拽向工程里添加文件时，我建议

72
00:03:39,920 --> 00:03:42,587
you have this Destination, Copy items if needed,
Destination 勾选 Copy items if needed

73
00:03:42,656 --> 00:03:45,757
otherwise, when you drag in a class, or structure, or
否则当你拖进来一个类、结构体什么的

74
00:03:45,826 --> 00:03:47,225
something, you'll be pointing to it.
Xcode 不会创建副本，只会引用原文件

75
00:03:47,293 --> 00:03:49,294
So if you change it in, wherever you got it from,
如果你如果你修改原文件

76
00:03:49,363 --> 00:03:50,729
it will be changing it in your project,
也就意味着修改了你工程的源代码

77
00:03:50,797 --> 00:03:52,631
so, it's usually what we wanna do.
所以通常都勾选这个选项创建副本

78
00:03:52,699 --> 00:03:53,732
Maybe that might be what you want,
可能你只想引用原文件

79
00:03:53,800 --> 00:03:56,835
in certain circumstances, but usually wanna copy it in.
某些情况是这样的，但通常要复制一份

80
00:03:56,904 --> 00:04:00,071
So let's take a look at this thing that I brought in,
所以我们来看看这个拖进来的文件

81
00:04:00,140 --> 00:04:03,641
it's a struct and it's gonna be the model of our FaceView.
它是个结构体，将会作为 FaceView 的模型

82
00:04:03,710 --> 00:04:06,044
And it's a really simple FacialExpression,
FacialExpression 就是面部表情

83
00:04:06,113 --> 00:04:09,380
that's what this represents, this struct.
这个结构体就代表的是这个

84
00:04:09,449 --> 00:04:11,015
And it has positions of the eyes,
它描述了眼睛的状态

85
00:04:11,084 --> 00:04:14,052
open eyes, closed eyes, squinting eyes, unfortunately,
睁眼，闭眼，眯着眼。虽然很不幸的

86
00:04:14,121 --> 00:04:16,955
we can't represent that in our view but it's in the model,
我们还不能在视图里展示，但模型里有这个选项

87
00:04:17,023 --> 00:04:19,123
we'll have to figure out the best we can do.
我们要考虑下最佳解决方案

88
00:04:19,192 --> 00:04:22,360
It's also got a mouth, and the mouth can frown or smirk, or
嘴巴可以是撅嘴（frown），讥笑（smirk）

89
00:04:22,428 --> 00:04:23,628
it can grin, or smile,
还可以咧嘴笑（grin），大笑（smile）

90
00:04:23,697 --> 00:04:27,732
notice there's nothing in this model about mouth curvature.
注意模型里并没有嘴巴曲率

91
00:04:27,801 --> 00:04:29,233
It doesn't know anything about mouth curvature,
甚至可以说是一无所知

92
00:04:29,302 --> 00:04:30,301
it just knows about grins and
模型只知道是咧嘴笑

93
00:04:30,370 --> 00:04:32,971
frowns, things like that, that's what the model is.
或是像撅嘴这类的表情

94
00:04:33,039 --> 00:04:37,209
It's also kinda cool, it knows how to give you a happier
模型还很酷的一点是能提供开心一点

95
00:04:37,277 --> 00:04:40,211
version of itself, or a sadder version of itself.
的面部表情或伤心一些的表情

96
00:04:40,280 --> 00:04:41,813
That's what these vars do,
也就是这两个变量的作用

97
00:04:41,882 --> 00:04:44,616
they just wanna return a happier or sadder.
它们返回一个开心或伤心些的版本

98
00:04:44,684 --> 00:04:48,620
But primarily, this struct is just an expression to keep
总的来说，这个结构体就负责

99
00:04:48,689 --> 00:04:53,291
track of the state of the eyes and the mouth.
保存眼睛和嘴巴的状态

100
00:04:53,359 --> 00:04:55,027
So I'm going to, in my controller,
我回到控制器

101
00:04:55,095 --> 00:04:58,329
create a green arrow to it, or a var for it.
创建一条绿色通道，也就是存储模型的变量

102
00:04:58,398 --> 00:05:00,365
We're gonna call it expression,
叫做 expression（表情）

103
00:05:00,434 --> 00:05:02,266
cuz it's a facial expression.
因为保存的是面部表情

104
00:05:02,335 --> 00:05:05,570
And it's type FacialExpression,
类型是 FacialExpression

105
00:05:05,639 --> 00:05:09,441
and actually,
事实上

106
00:05:09,509 --> 00:05:12,577
let's have a starting facial expression have eyes,
让我们定义一个初始的面部表情

107
00:05:12,646 --> 00:05:18,516
which are, let's say, open, and a mouth, which is a grin.
眼睛是睁开（.open）的，嘴巴是在咧嘴笑（.grin）

108
00:05:18,585 --> 00:05:20,419
That sound like a happy place to start.
看样子是很开心的

109
00:05:22,322 --> 00:05:22,954
So that's great,
这个就完成了

110
00:05:23,022 --> 00:05:27,725
now, remember that the primary job of a controller
接着我们看，控制器的主要任务是

111
00:05:27,794 --> 00:05:31,062
is to interpret the model for the view and vice versa.
把模型转换给视图，从视图更新模型

112
00:05:31,131 --> 00:05:34,165
So I'm gonna add a private function here-
所以我要在这里写一个私有函数

113
00:05:34,234 --> 00:05:36,367
you'll all often have a method or
你经常会有一个或几个

114
00:05:36,436 --> 00:05:38,769
a number of methods in your controller like this.
这样的方法在控制器中

115
00:05:38,838 --> 00:05:40,672
This one I'm gonna call updateUI.
这个我把它叫做 updateUI

116
00:05:41,841 --> 00:05:44,275
And the job of this method is just to
这个方法的任务就是

117
00:05:44,344 --> 00:05:47,812
make the model match the UI, tha's i's job.
让界面和模型保持一致

118
00:05:47,881 --> 00:05:49,915
Tha's what this method is gonna do.
这个方法就是更新界面

119
00:05:49,983 --> 00:05:52,817
So, what do we have to do to make our model,
那我们要怎么才能让模型

120
00:05:52,886 --> 00:05:54,586
this facial expression, match our UI?
这个 FacialExpression 和界面同步呢？

121
00:05:54,655 --> 00:05:56,487
Well, we have to deal with the eyes and
我们要展示眼睛

122
00:05:56,556 --> 00:05:58,389
we have to deal with the mouth.
还有嘴巴的状态

123
00:05:58,458 --> 00:06:02,960
So, let's deal with the eyes first, that's pretty easy, so,
所以我们先来处理眼睛，简单的部分

124
00:06:03,029 --> 00:06:06,664
I'm just going to switch on my expression's eyes.
我只需要用 switch 判断 expression.eyes

125
00:06:06,733 --> 00:06:10,701
And in the case that the eyes are open in the model,
如果眼睛是睁开（.open）的情况（case）

126
00:06:10,770 --> 00:06:14,539
then it's easy, I can just take my faceView and
那很简单，我就让 faceView

127
00:06:14,607 --> 00:06:19,444
set it's eyesOpen to true, that's obvious how we do that.
的 eyesOpen 为 true，这是理所当然的

128
00:06:19,512 --> 00:06:23,048
And this face, you remember, is this outlet,
faceView 就是上面这个出口

129
00:06:23,116 --> 00:06:27,552
that I just created there, and so, that's obvious.
我刚才创建的那个

130
00:06:27,621 --> 00:06:30,922
How about the case where the eyes are closed in the model?
如果眼睛是闭着（.closed）的情况呢？

131
00:06:30,990 --> 00:06:33,457
Well, that's the faceView.eyesOpen,
那 faceView.eyesOpen

132
00:06:33,526 --> 00:06:35,493
are gonna be false.
就设为 false

133
00:06:35,562 --> 00:06:38,729
And finally, there's this case in the model
最后如果模型里的眼睛

134
00:06:38,798 --> 00:06:41,900
where we're squinting, and here,
是眯着眼的（.squinting）

135
00:06:41,968 --> 00:06:44,236
I don't really have a way to represent that.
我们现在并没有方法展示它

136
00:06:44,304 --> 00:06:47,038
So I'm just going to say that in that case our eyes
所以这种情况下

137
00:06:47,107 --> 00:06:50,642
are gonna be closed because, squinting is more like having
我就让眼睛闭着，因为眯着眼

138
00:06:50,711 --> 00:06:52,944
your eyes closed than having them open.
更接近于闭眼而不是睁眼

139
00:06:53,013 --> 00:06:56,481
But we don't always have exactly the view we want to
因为我们的视图不一定完全满足

140
00:06:56,550 --> 00:06:58,517
represent our model, so we're doing the best we can here.
我们要展示的模型，所以尽力而为就行了

141
00:07:00,119 --> 00:07:02,888
So that is the eyes, pretty straightforward.
眼睛这部分就处理完了，很简单

142
00:07:02,956 --> 00:07:05,756
Now the mouth, I could do the same thing for
现在是嘴。虽然我可以用同样的方法

143
00:07:05,825 --> 00:07:08,125
the mouth here, case expression.mouth,
switch-case 判断 expression.mouth

144
00:07:08,194 --> 00:07:10,394
if it's a grin, set the mouth curvature to this.
如果是 .grin，就让 mouthCurvature 为某个值

145
00:07:10,463 --> 00:07:12,130
If it's normal, set the mouth curvature to that,
如果是 .normal，就设为另外某个值

146
00:07:12,199 --> 00:07:14,198
but that code is kind of messy,
但那样的代码会很混乱

147
00:07:14,267 --> 00:07:19,704
(make some space here so it's up higher), what if
（稍微留点空出来，代码在上面方便你们看）

148
00:07:19,773 --> 00:07:24,976
I created a little private var here, actually make it a let.
为什么我不创建一个私有变量，更准确说是常量

149
00:07:25,045 --> 00:07:28,513
And I'm gonna call it mouthCurvatures, and
然后叫做 mouthCurvatures

150
00:07:28,581 --> 00:07:31,015
it's gonna be a dictionary, and in the dictionary,
类型是字典

151
00:07:31,084 --> 00:07:37,822
the values are gonna be FacialExpression.MouthPositi-
键的类型是 FacialExpression.Mouth

152
00:07:37,891 --> 00:07:40,625
ons, maybe a grin.
比如其中的 .grin

153
00:07:40,694 --> 00:07:43,594
And the value is gonna be a mouth curvature, so
值就是嘴的曲率

154
00:07:43,663 --> 00:07:44,929
what's a good thing for a grin?
适合咧嘴笑的值是多少？

155
00:07:44,997 --> 00:07:46,964
I think I decided 0.5.
我认为 0.5 不错

156
00:07:47,033 --> 00:07:49,634
So this is just gonna be a dictionary with
所以这就是个字典，格式是

157
00:07:49,703 --> 00:07:53,705
mouth position in the model, colon, mouthCurvatures for the view.
模型里嘴的状态，冒号，然后嘴的曲率

158
00:07:53,773 --> 00:07:56,374
So I'm just creating this little mapping data structure.
这个字典存储了两种值之间的映射关系

159
00:07:56,443 --> 00:07:58,409
So let's do this for all, let's map this.
所以我们把所有的都列出来

160
00:07:58,478 --> 00:08:00,811
For all of our facial expressions right here.
枚举 FacialExpression 里所有的情况

161
00:08:00,880 --> 00:08:02,313
Notice, by the way,
顺便一提

162
00:08:02,381 --> 00:08:06,818
that Swift was able to infer the type of this dictionary.
Swift 能够推测出字典的类型

163
00:08:06,887 --> 00:08:10,254
Cuz it only has one item in it, and the types of those two
因为里面已经有一个键值对了，其类型

164
00:08:10,323 --> 00:08:13,724
things are obvious from what they are.
键和值两个的类型都是显然的

165
00:08:13,793 --> 00:08:17,028
So now that it knows that, by the way,
所以 Swift 能够推导出来

166
00:08:17,097 --> 00:08:21,365
we can be a little more succinct and just say like,
现在还能更简明——省略前面类型的部分

167
00:08:21,434 --> 00:08:24,736
frown is -1.0 and smile is 1.0.
比如撅嘴是 .frown:-1.0, 大笑是 .smile:1.0

168
00:08:24,805 --> 00:08:30,841
And obviously neutral would be 0.0.
当然，自然状态（.neutral）是 0.0

169
00:08:30,910 --> 00:08:31,709
Did I get them all?
我都列出来了吗？

170
00:08:31,778 --> 00:08:32,844
Smirk, how about smirk?
好像忘了 .smirk，讥笑

171
00:08:32,912 --> 00:08:38,717
Nope, that smirk we'll say is -0.5.
就设为 -0.5 吧

172
00:08:40,220 --> 00:08:42,119
So I've just put those mouth curvatures in this nice
我把嘴巴曲率都放到了

173
00:08:42,188 --> 00:08:43,087
little table.
这个对照表里

174
00:08:43,156 --> 00:08:44,889
And so now in my update UI,
现在在 updateUI 里

175
00:08:44,958 --> 00:08:48,392
I'm just gonna set my faceView's mouthCurvature
我只需要吧 faceView.mouthCurvature

176
00:08:48,461 --> 00:08:51,496
equal to looking up in the mouthCurvatures,
赋值为从 mouthCurvatures 里找到的

177
00:08:51,565 --> 00:08:58,669
the model's mouth.
模型里嘴的状态对应的值

178
00:08:58,738 --> 00:09:01,639
I just kinda wanna do it this way to kinda show you that you
我这样做的原因是告诉你们

179
00:09:01,708 --> 00:09:04,475
don't always have to forcefully case every single
你们不总是需要用 switch-case

180
00:09:04,544 --> 00:09:05,844
thing when you have an enum.
处理枚举类型并不总是要这样

181
00:09:05,913 --> 00:09:07,545
Sometimes you can use things like this.
有些时候可以借助这样的东西简化

182
00:09:07,614 --> 00:09:08,946
Now, I have an error there,
但现在 Xcode 提示有个错误

183
00:09:09,015 --> 00:09:10,314
anybody know why I have an error?
有人知道为什么吗？

184
00:09:10,383 --> 00:09:11,149
Can anyone guess?
有人能猜一下吗？

185
00:09:16,322 --> 00:09:16,988
Optional, yeah.
是的，可选类型

186
00:09:17,057 --> 00:09:18,689
Alright, people are getting the optional thing.
好了，大家明白可选类型这个东西了

187
00:09:18,758 --> 00:09:20,425
Good. mouthCurvature,
很好，mouthCurvature

188
00:09:20,494 --> 00:09:21,593
what type is that?
嘴巴曲率的类型是什么？

189
00:09:21,662 --> 00:09:24,762
That is a double, and mouthCurvature sub
是一个 Double，但是这个的类型呢？

190
00:09:24,831 --> 00:09:27,632
expression.mouth, what type is that?
mouthCurvatures[expression.mouth]

191
00:09:27,701 --> 00:09:29,533
It's an optional double.
它是 Double? 类型的

192
00:09:29,602 --> 00:09:33,337
And that's because this expression might not be
因为可能这个表情/表达式的结果

193
00:09:33,406 --> 00:09:34,506
in that dictionary.
可能不在字典里

194
00:09:34,574 --> 00:09:37,508
So I'm gonna use that defaulting thing we learned
所以我要用提供可选默认值的方法

195
00:09:37,577 --> 00:09:40,044
and say, if I can't find the expression mouth,
如果不能找到 expression.mouth

196
00:09:40,113 --> 00:09:43,047
we are gonna have neutral mouth, not smiling or
那就用最自然的 .neutral

197
00:09:43,116 --> 00:09:45,383
frowning as our curvature.
既不开心也不伤心

198
00:09:48,688 --> 00:09:52,156
Now, we have this great update UI.
现在我们 updateUI 就写好了

199
00:09:52,225 --> 00:09:55,192
When should we call this thing?
我们什么时候调用这个方法呢？

200
00:09:55,261 --> 00:09:58,963
Well, we certainly need to call this thing anytime our
我们必须要在每次

201
00:09:59,032 --> 00:10:00,364
model changes.
模型变更的时候调用

202
00:10:00,433 --> 00:10:02,934
If our model changes to have a different expression,
如果我们的模型代表了另一个表情

203
00:10:03,003 --> 00:10:04,068
we gotta update our UI.
我们就需要更新界面

204
00:10:04,137 --> 00:10:05,836
So how are we gonna do that?
要怎么实现？

205
00:10:05,905 --> 00:10:08,439
We're gonna use this cool feature that I talked about
要用到之前讲的 Swift 很厉害的功能

206
00:10:08,507 --> 00:10:13,478
last time called property observers, this didSet thing.
就是上次讲的属性观察器中的 didSet

207
00:10:13,547 --> 00:10:16,648
So didSet allows you on any of your vars,
didSet 可以用在（几乎）所有的变量上

208
00:10:16,717 --> 00:10:19,417
if it changes, you can execute some code.
如果值发生了改变，就运行里面的代码 

209
00:10:19,486 --> 00:10:22,019
So anytime someone sets this expression,
所以如果有人设置了 expression

210
00:10:22,088 --> 00:10:24,122
I'm just going to update my UI.
我们就调用 updateUI() 更新界面

211
00:10:28,161 --> 00:10:29,827
Now, there's one other place that I wanna
现在还有种情况我想

212
00:10:29,896 --> 00:10:33,564
update my UI though, it's a little less obvious, and
更新界面，虽然不那么容易想到

213
00:10:33,633 --> 00:10:36,568
that is with this property observer.
那就是在 faceView 的 didSet 里

214
00:10:39,171 --> 00:10:40,905
What am I doing here?
我这是为了什么？

215
00:10:40,974 --> 00:10:42,607
This property is the outlet,
这个属性是个出口

216
00:10:42,676 --> 00:10:45,743
that thing I Ctrl+dragged to my faceView.
按 control 拖拽过来的 FaceView

217
00:10:45,812 --> 00:10:49,681
And when we first start up, it's not set.
程序刚开始运行的时候是空的

218
00:10:49,749 --> 00:10:53,318
iOS takes a few microseconds to actually connect this up.
iOS 系统需要几微秒的时间建立关联

219
00:10:53,387 --> 00:10:56,487
That's why this is an optional, remember?
还记得，这就是它类型为可选的原因吗？

220
00:10:56,556 --> 00:11:01,492
In that short amount of time, what if the model gets set.
如果在这段时间里，模型被赋了值

221
00:11:01,561 --> 00:11:03,927
Then update UI is not gonna work because the faceView
updateUI 并没什么用

222
00:11:03,996 --> 00:11:05,830
hasn't been connected yet.
因为 faceView 还没关联上

223
00:11:05,899 --> 00:11:07,632
So that's no good.
这是不好的

224
00:11:07,701 --> 00:11:11,836
Also we initialized our FacialExpression to be this.
再说一下，我们用这个 FacialExpression 初始化

225
00:11:11,905 --> 00:11:16,741
When you initialize something, didSet does not get called.
但赋初值的时候 didSet 是不会被调用的

226
00:11:16,810 --> 00:11:19,144
didSet is only called if someone externally sets
didSet 只会在其他情况下赋值

227
00:11:19,212 --> 00:11:20,445
the expression.
才会被调用

228
00:11:20,514 --> 00:11:24,648
The initial thing does not cause it to be set.
初始化的时候是不会调用

229
00:11:24,717 --> 00:11:27,451
So when is this didSet gonna happen?
那这个 didSet 什么时候被调用呢？

230
00:11:27,520 --> 00:11:32,123
It's gonna happen only once when iOS hooks up this outlet
只会发生一次：当 iOS 关联出口

231
00:11:32,191 --> 00:11:35,526
to that faceView, then this didSet is gonna get called.
到 FaceView 的时候会调用 didSet

232
00:11:35,595 --> 00:11:37,362
That's the only time it's ever gonna get called.
这是唯一一次会调用的时候

233
00:11:37,430 --> 00:11:39,764
But at that time, we're gonna update our UI.
那个时候我们需要更新界面

234
00:11:39,833 --> 00:11:43,401
Now, there's one other minor thing here.
这里有个细节

235
00:11:43,469 --> 00:11:51,009
What if this gets called before this happens?
如果 expression 在 faceView 初始化前被赋了值

236
00:11:52,211 --> 00:11:55,412
This is gonna crash our program
使用 faceView 就会导致程序崩溃

237
00:11:55,481 --> 00:11:59,517
because until this gets hooked up to iOS, this is nil.
直到 iOS 完成关联前，faceView 都是 nil

238
00:12:01,320 --> 00:12:04,055
The only reason we don't have to say exclamation point here
这里不需要用 ! 强制解包的原因是

239
00:12:04,124 --> 00:12:06,824
is cuz we have this implicitly unwrapped optional here, but
faceView 是个隐式解析的可选类型

240
00:12:06,893 --> 00:12:08,092
it is an optional.
但终究还是可选类型

241
00:12:08,161 --> 00:12:09,794
So how can we deal with that?
总之，这种情况怎么处理呢？

242
00:12:09,862 --> 00:12:12,263
We don't want update UI to crash our program
我们不希望 updateUI 导致程序崩溃

243
00:12:12,332 --> 00:12:14,832
if the expression should happen to be set before that
也就是 expression 被赋了值

244
00:12:14,901 --> 00:12:16,434
thing gets wired up.
faceView 却还没关联上

245
00:12:16,502 --> 00:12:19,337
Now that thing gets wired up pretty soon, so
虽然马上就会关联上

246
00:12:19,405 --> 00:12:21,639
probably not likely to happen, but it could.
因此几乎不会发生，但可能性是有的

247
00:12:21,708 --> 00:12:24,775
So, we're gonna do that by using this chaining,
方法是在 faceView 后加 ? 解决

248
00:12:24,844 --> 00:12:26,544
this optional chaining.
使用可选链

249
00:12:26,613 --> 00:12:28,146
Remember the optional chaining,
还记得可选链

250
00:12:28,215 --> 00:12:29,880
where you can put a question mark there.
就是放个 ? 在那里

251
00:12:29,949 --> 00:12:33,384
And if the thing that you put the question mark on evaluates
如果那个的值是 nil

252
00:12:33,453 --> 00:12:36,654
to nil, the rest of that line of code is just ignored.
这行剩下的代码都会被忽略

253
00:12:36,722 --> 00:12:40,358
Perfect, faceView?.eyesOpen, if faceView's not set,
很好，如果 faceView 是 nil，faceView?.eyesOpen

254
00:12:40,427 --> 00:12:41,726
we'll just ignore that.
这行代码就会被忽略

255
00:12:41,795 --> 00:12:43,561
We're not gonna set the eyes open to anything,
不会给 eyesOpen 赋值

256
00:12:43,630 --> 00:12:45,630
that line is just gonna be aborted immediately.
那行代码会立刻停止运行

257
00:12:47,534 --> 00:12:50,768
This is something you often wanna do in your update
所以经常使用可选链，是更新界面

258
00:12:50,837 --> 00:12:54,572
UI things is protect against your outlets not being set
出口却没关联上时，保护程序的做法

259
00:12:58,144 --> 00:13:01,880
And it's all gonna be fine, because if this got sent, and
这样就万事大吉了，即使 didSet 被调用了

260
00:13:01,948 --> 00:13:04,882
this has not been, and then this happens, and
faceView 没有关联，此时调用 updateUI

261
00:13:04,951 --> 00:13:08,152
none of these lines of code execute, no problem.
这些问题代码不会执行，不会造成问题

262
00:13:08,221 --> 00:13:10,054
Because when this does get hooked up,
因为当 faceView 关联上之后

263
00:13:10,123 --> 00:13:11,655
this is gonna get called again.
updateUI 会再次被调用

264
00:13:11,724 --> 00:13:13,258
And this time, it'll be able to do it.
这个时候就能更新了

265
00:13:16,896 --> 00:13:17,829
So that it.
好了

266
00:13:17,897 --> 00:13:19,797
Let's run our little app here and
让我们运行下程序

267
00:13:19,866 --> 00:13:23,635
see if we get an open eyes grin.
看看是不是睁着眼睛咧嘴笑

268
00:13:23,703 --> 00:13:24,768
In other words,
换句话说

269
00:13:24,837 --> 00:13:28,206
let's see if our UI reflects what's in our model.
UI 是否反映了模型的内容

270
00:13:28,274 --> 00:13:32,277
And sure enough, open eyes and a little grin.
是的，确实是这样的

271
00:13:32,345 --> 00:13:38,349
Let's try closed
我们试下闭着眼睛

272
00:13:38,417 --> 00:13:44,389
eyes, closed and
eyes: .closed

273
00:13:44,457 --> 00:13:50,061
a little frown.
撅着嘴

274
00:13:50,130 --> 00:13:51,862
Bingo!
很好！

275
00:13:51,931 --> 00:13:54,966
So now we have done what we need to do in our controller,
现在控制器就写好了

276
00:13:55,035 --> 00:13:57,502
which is we're interpreting our model for our view.
也就是把模型转换给视图的部分

277
00:13:57,571 --> 00:13:59,303
And anytime we set the model from now on,
现在每次更改模型

278
00:13:59,372 --> 00:14:00,938
it's gonna update our view automatically.
视图都会自动更新

279
00:14:01,006 --> 00:14:03,874
So the question is, what if I forgot to put this little
有人问，如果我忘了可选链

280
00:14:03,943 --> 00:14:06,143
question mark right here?
忘了加 ? 会怎样

281
00:14:06,212 --> 00:14:09,814
Probably everything would be fine because you don't set
很可能什么事也没有，因为你不会

282
00:14:09,883 --> 00:14:13,584
your model before that outlet gets wired up by iOS cuz it
在出口被 iOS 关联前去更改模型

283
00:14:13,653 --> 00:14:15,253
wires it up really soon.
而且关联一般要不了多少时间

284
00:14:15,321 --> 00:14:19,189
But if you did,
但如果真的发生了

285
00:14:19,258 --> 00:14:20,291
And so that's how you would know,
（当然这也是你知道发生了的方法）

286
00:14:20,360 --> 00:14:22,159
"oops," you messed that up.
“糟糕”，搞砸了

287
00:14:22,228 --> 00:14:24,628
And sometimes you'll forget to put that question mark there,
有些时候你忘了加问号

288
00:14:24,697 --> 00:14:26,180
You do all your coding and you never call that model earlier.
你写了很多代码，从来没有过早地设置模型

289
00:14:26,181 --> 00:14:27,664
it's fine.
什么问题都没有

290
00:14:27,733 --> 00:14:29,701
But then later, you change your code in a way that
但如果之后你把代码改成了

291
00:14:29,769 --> 00:14:31,869
does accept the model before that thing, and boom.
在关联好 UI 前就更新模型，那就炸了

292
00:14:31,938 --> 00:14:33,304
It crashes, and you find it right away.
程序崩溃，你马上就会知道

293
00:14:33,372 --> 00:14:34,372
That's why crashing is
所以程序崩溃

294
00:14:34,441 --> 00:14:36,340
not always the worst thing in the world.
并不总是世界上最糟糕的事情

295
00:14:36,409 --> 00:14:38,076
Crashing helps you find bugs like that.
崩溃能帮你找到这样的 bug

296
00:14:39,479 --> 00:14:40,778
You just hope you don't ship it out, and
当然希望你还没有发布这个程序

297
00:14:40,847 --> 00:14:44,081
the customers find that bug for you that way.
让用户通过程序崩溃帮你发现问题

298
00:14:44,150 --> 00:14:45,949
So that's it, that's all I wanted to do is show
好了，这就是我想向你们展示的

299
00:14:46,018 --> 00:14:47,351
you now we have a complete MVC.
有一个完整 MVC 的程序

300
00:14:47,419 --> 00:14:49,053
It's got a model, it's got a view,
有模型，有视图

301
00:14:49,122 --> 00:14:52,389
it's got a controller that is interpreting for each other.
还有一个控制器负责相互转换

302
00:14:52,458 --> 00:14:53,624
So we can go back to our slides and
我们可以回到幻灯片

303
00:14:53,693 --> 00:14:54,692
learn about gestures, and
学习手势的相关知识

304
00:14:54,760 --> 00:14:56,561
then we'll add some gestures to this thing.
然后再来给程序添加手势识别

305
00:15:01,634 --> 00:15:04,735
So, how do we get those touches?
我们要如何获得那些触摸事件？

306
00:15:04,804 --> 00:15:07,872
Now, it is possible to get notified
当然，我们能够得到通知

307
00:15:07,940 --> 00:15:11,575
of raw touch events like a touch, meaning a finger,
接受那些未经处理的事件，也就是一根手指

308
00:15:11,644 --> 00:15:15,646
went down on the screen, it moved, it went up.
按在了屏幕上，移动了，最后抬起来了

309
00:15:15,714 --> 00:15:16,981
Two fingers went down,
两根手指按下来了

310
00:15:17,050 --> 00:15:20,351
you can find out all about that, but we never do.
你可以得知这些信息，但是我们不会这么做

311
00:15:20,419 --> 00:15:23,787
Too complicated, trying to figure out whether this, down,
对你们来说太复杂了，要判断这个按下

312
00:15:23,856 --> 00:15:27,691
swipe, up is a swipe versus just moving, that's too hard.
扫过再抬起，到底是轻扫还是移动，太复杂了

313
00:15:27,760 --> 00:15:30,094
So we're gonna let iOS do that for us.
所以我们让 iOS 帮我们处理

314
00:15:30,163 --> 00:15:33,464
And we call that interacting with multi touch,
我们把这个叫做多点触控

315
00:15:33,533 --> 00:15:35,400
touch via gestures.
作为手势处理

316
00:15:35,468 --> 00:15:37,167
So we're not even gonna learn about about the raw
所以我不会讲解未经处理的

317
00:15:37,236 --> 00:15:39,871
touch input in this course, just gestures.
触控输入，这门课我只讲手势

318
00:15:40,940 --> 00:15:43,341
So gestures are recognized
所以手势识别

319
00:15:43,409 --> 00:15:46,678
by this class called the UIGestureRecognizer.
是由 UIGestureRecognizer 完成的

320
00:15:46,746 --> 00:15:49,413
Actually, not by UIGestureRecognizer itself,
更准确地说不是 UIGestureRecognizer 这个类本身

321
00:15:49,482 --> 00:15:51,015
that's an abstract class.
那是个 "abstract" class

322
00:15:51,084 --> 00:15:53,017
How many people know what an abstract class is?
抽象类。有多少人知道这是什么？

323
00:15:53,086 --> 00:15:54,651
Raise your hand if you know what that is.
知道的举下手

324
00:15:54,720 --> 00:15:56,253
Okay, so I'll take a second to tell ya.
好吧，那我花点时间解释一下

325
00:15:56,322 --> 00:15:59,089
So an abstract class is a class that, it's only
抽象类

326
00:15:59,158 --> 00:16:02,659
purpose in life is to be the super class of other classes.
它的目的就是作为其他类的父类

327
00:16:02,728 --> 00:16:06,097
And you never actually create an abstract class, okay?
你从来不会直接构造一个抽象类

328
00:16:06,165 --> 00:16:08,198
You only create subclasses of it,
你只会构造这个类的子类

329
00:16:08,267 --> 00:16:10,468
instances of subclasses of it.
构造出子类的实例

330
00:16:10,537 --> 00:16:13,304
So UIGestureRecognizer is abstract, you would never
所以 UIGestureRecognizer 是抽象的

331
00:16:13,373 --> 00:16:16,307
create a UI, you'd never call an initializer on UI gesture
你不会调用它的构造器

332
00:16:16,376 --> 00:16:17,074
recognizer.
来构造手势识别器

333
00:16:17,143 --> 00:16:19,009
Instead there's a bunch of subclasses which I'm gonna
取而代之的是我要讲的一些子类

334
00:16:19,078 --> 00:16:21,379
talk about and you would call the initializer on them.
你要调用的是这些子类的构造器

335
00:16:23,082 --> 00:16:27,785
Now there's two parts to using a gesture recognizer here.
使用手势识别器由两个步骤

336
00:16:27,853 --> 00:16:30,554
One is you have to ask a UIView, please start
第一步是告诉 UIView

337
00:16:30,623 --> 00:16:34,491
recognizing this gesture, like a swipe or a pan or whatever.
开始识别这个手势，比如轻扫或拖动什么的

338
00:16:34,560 --> 00:16:37,695
And then number two is, when the recognizer does recognize
接着第二步，当识别器识别到了手势

339
00:16:37,763 --> 00:16:40,097
it, it wants to call you back with a handler,
它会通知负责处理的对象

340
00:16:40,166 --> 00:16:42,500
what we call a handler, a gesture handler.
gesture handler，处理手势的对象

341
00:16:42,569 --> 00:16:45,035
So there's the recognizer that you add to a view and
所以第一步是把识别器添加到视图上

342
00:16:45,104 --> 00:16:47,838
then there's the handler, anybody can be the handler,
第二步是通知处理事件的对象，谁都可以负责

343
00:16:47,907 --> 00:16:48,672
as you'll see.
你等会儿会看到的

344
00:16:48,741 --> 00:16:52,343
Almost always it's either the view itself or a controller,
大部分情况下不是视图本身就是控制器

345
00:16:52,412 --> 00:16:54,278
but anybody could be it.
但理论上谁都可以

346
00:16:54,347 --> 00:16:57,715
Now the adding of the gesture recognizer is done with
添加手势识别器是通过

347
00:16:57,783 --> 00:17:01,518
a method called addGestureRecognizer in UIView.
UIView 的 addGestureRecognizer 方法

348
00:17:01,587 --> 00:17:04,922
And that method is usually called by controllers,
通常由控制器添加

349
00:17:04,991 --> 00:17:06,857
why do controllers call that?
为什么是控制器呢？

350
00:17:06,926 --> 00:17:10,428
That's because a controller wants to control whether
因为控制器想控制

351
00:17:10,496 --> 00:17:14,198
the things in its view recognize certain gestures.
当识别到手势时发生的事情

352
00:17:14,267 --> 00:17:16,767
They might wanna turn off certain gestures or or
说不定是要停止识别某种手势

353
00:17:16,836 --> 00:17:18,569
not turn on certain gestures, so
或者是不启用某些手势

354
00:17:18,638 --> 00:17:21,072
the controller is often controlling that.
控制器通常会这样做

355
00:17:21,140 --> 00:17:25,208
But occasionally you do get a UIView that will add
但有的时候 UIView 会

356
00:17:25,277 --> 00:17:28,379
a gesture to itself, like scroll view.
给自己添加一个识别器，比如 UIScrollView

357
00:17:28,447 --> 00:17:31,182
Because a scroll view without the pan gesture, or
滚动视图不能识别拖动

358
00:17:31,250 --> 00:17:33,718
without the pinching gesture if it can zoom,
如果能缩放的不能识别缩放手势

359
00:17:33,787 --> 00:17:35,386
it's not even a scroll view.
那就不能被叫做滚动视图了

360
00:17:35,454 --> 00:17:36,920
In other words, that gesture is so
也就是说，手势识别

361
00:17:36,989 --> 00:17:40,124
fundamental to what a scroll view is that scroll view adds
是滚动视图的基础，以至于它自己给添加上了

362
00:17:40,193 --> 00:17:41,910
It'd, you'd have some API to turn it off, but it adds it to
你可以调用某些 API 停止识别

363
00:17:41,911 --> 00:17:43,628
it to itself.
但它已经自动添加上了

364
00:17:43,696 --> 00:17:47,297
itself, it doesn't make some controller add this gesture,
不需要让控制器去添加

365
00:17:47,366 --> 00:17:49,333
it just recognizes pan and pinch.
它自己就能识别拖动和缩放手势了

366
00:17:49,402 --> 00:17:51,135
So mostly it's done by controllers,
总之大部分时候是控制器

367
00:17:51,204 --> 00:17:52,369
though you'll see that.
我们等会儿会看到

368
00:17:52,438 --> 00:17:53,971
The second thing, the handler,
第二个部分，负责处理事件的对象

369
00:17:54,040 --> 00:17:56,506
okay that could either be the controller or the view.
可以是控制器，也可以是视图

370
00:17:56,575 --> 00:18:00,477
And what it really depends on is whether the gesture affects
取决于这个手势到底影响了谁

371
00:18:00,546 --> 00:18:01,445
the model, or
是模型

372
00:18:01,514 --> 00:18:05,148
whether the gesture affects just the view, okay.
还是仅仅视图本身

373
00:18:05,217 --> 00:18:06,883
If the gesture only affects the view,
如果只影响视图的话

374
00:18:06,952 --> 00:18:08,586
then the view will probably handle it.
通常视图就自行处理了

375
00:18:08,655 --> 00:18:11,088
But if the gesture affects the model directly,
但如果会直接影响到模型

376
00:18:11,157 --> 00:18:12,123
now the controller has to
那控制器就需要

377
00:18:12,191 --> 00:18:13,958
handle it because a view can't see the model.
负责了，因为视图“看”不到模型

378
00:18:17,297 --> 00:18:18,896
So the handler is either controller or view, and
所以负责的不是控制器就是视图

379
00:18:18,965 --> 00:18:19,830
you'll see that in the demo.
等会演示的时候你会看到的

380
00:18:19,898 --> 00:18:22,166
I'm gonna have one handler that's a model, one and
其中一个由模型负责

381
00:18:22,234 --> 00:18:25,869
one that controls view and you'll see where we put them.
其中一个控制视图的负责，你会看到我放在哪里的

382
00:18:25,938 --> 00:18:28,839
Alright, so what's the code look like to add a gesture
所以用代码添加一个识别器

383
00:18:28,907 --> 00:18:30,140
recognizer to a view?
到视图是怎么做的？

384
00:18:30,209 --> 00:18:31,308
So for my example here,
我这里的这个例子

385
00:18:31,377 --> 00:18:33,977
let's say you had a view, and in this code I'm gonna
假如你有个视图，我这里的代码

386
00:18:34,046 --> 00:18:36,246
put here by the way is gonna be in a controller.
是在控制器里的

387
00:18:36,315 --> 00:18:39,549
Let's say it has one of its views that it wants to add
比如说其中一个视图想要

388
00:18:39,618 --> 00:18:42,987
a pan gesture, a pan gesture is put your finger down on
添加一个拖动（pan）手势识别器，就是手指按下

389
00:18:43,056 --> 00:18:45,255
the screen and move around.
在屏幕上到处移动

390
00:18:45,324 --> 00:18:48,625
That's called panning around in the view.
这就叫做在视图里 pan，拖动

391
00:18:48,694 --> 00:18:54,365
So this is what it looks like, a good place to add a gesture
这就是代码的样子。添加手势识别器的好地方

392
00:18:54,433 --> 00:18:59,470
recognizer is in the didSet of an outlet for that view.
是在到该视图的 didSet 里

393
00:18:59,539 --> 00:19:02,740
Because that's, as soon as you can get a hold of it anyway,
最终都要添加，不如当你一得到视图

394
00:19:02,808 --> 00:19:05,476
your iOS just sets, set that outlet up for you, so
iOS 刚把出口关联好

395
00:19:05,544 --> 00:19:07,545
now you've got a hold of that view.
现在你有了视图

396
00:19:07,614 --> 00:19:09,413
Now you can send a message to that view,
就给视图发个消息

397
00:19:09,481 --> 00:19:11,048
addGestureRecognizer.
调用 addGestureRecognizer

398
00:19:11,117 --> 00:19:14,318
Here I have this var, this outlet called pannableView,
这个出口叫做 pannableView，能被拖动的视图

399
00:19:14,387 --> 00:19:18,055
this is the view that I wanna add the pan gesture to.
因为这是我想要给它添加拖动手势

400
00:19:18,124 --> 00:19:20,457
And you can see that in its didSet,
在它的 didSet 里

401
00:19:20,526 --> 00:19:22,826
in other words when iOS wires this up,
也就是当 iOS 关联好了之后

402
00:19:22,895 --> 00:19:25,829
I'm going to do this addGestureRecognizer.
我就调用 addGestureRecognizer

403
00:19:25,898 --> 00:19:28,799
First I'm gonna create the gesture recognizer,
首先创建一个手势识别器

404
00:19:28,868 --> 00:19:32,269
notice I'm saying UIPanGestureRecognizer, in it,
注意我用的是 UIPanGestureRecognizer

405
00:19:32,338 --> 00:19:33,904
in the initializer for that.
的构造器

406
00:19:33,973 --> 00:19:37,074
Not UIGestureRecognizer, I'm creating a concrete
而不是 UIGestureRecognizer

407
00:19:37,143 --> 00:19:39,309
gesture recognizer which is for panning.
我创建的是具体负责拖动的手势识别器

408
00:19:39,378 --> 00:19:42,312
And that it has two arguments, the both of these arguments
它由两个参数

409
00:19:42,381 --> 00:19:44,682
are the handler, how this thing is handled.
两个都是负责决定如何处理事件的

410
00:19:44,751 --> 00:19:47,117
The target is who's gonna handle it, and
target，处理事件的目标对象

411
00:19:47,186 --> 00:19:50,354
the action is what method is going to handle it.
action，是传入具体负责处理方法的存根

412
00:19:50,423 --> 00:19:51,989
So now in the case here, the target,
我们这里举的例子

413
00:19:52,058 --> 00:19:54,758
I'm having the target will be myself, the view controller.
目标对象就是 self，也就是视图控制器本身

414
00:19:54,827 --> 00:19:57,127
This is obviously in the view controller because this is in
很显然这段代码在视图控制器里

415
00:19:57,196 --> 00:19:58,395
an outlet property observer,
因为这是出口的属性观察器

416
00:19:58,464 --> 00:20:00,364
that would only make sense in a view controller.
只有在视图控制器里才说得过去

417
00:20:00,433 --> 00:20:03,634
And so the target is myself, I'm going to set,
所以目标对象就是控制器

418
00:20:03,702 --> 00:20:07,037
ask when this pan gestures starts to be recognized
我会要求当拖动控制器识别到手势后

419
00:20:07,106 --> 00:20:11,108
it's gonna be sending me the action here to handle it.
要发送给我这个函数来处理事件

420
00:20:11,177 --> 00:20:15,278
And the action, you notice you have to say #selector to
这个函数，注意用了 #selector

421
00:20:15,347 --> 00:20:16,914
specify the method.
来指定是哪个方法的存根

422
00:20:16,983 --> 00:20:19,750
Don't get confused the difference between a function
注意区别函数类型

423
00:20:19,819 --> 00:20:22,152
type, a type that is a function and
（描述函数的类型）

424
00:20:22,221 --> 00:20:24,755
an actual method in a class.
和类里的一个实际的方法

425
00:20:24,824 --> 00:20:28,292
We use #selector to say this is a method,
我们用 #selector 表示这是个方法

426
00:20:28,361 --> 00:20:32,229
I wanna call this specific method in my class.
我想要调用类里的这个方法

427
00:20:32,298 --> 00:20:34,898
And notice I've said ViewController.pan(
我用的是 ViewController.pan(recognizer:)

428
00:20:34,967 --> 00:20:38,569
recognizer:), well that means that the method that's gonna
意思是这个方法

429
00:20:38,638 --> 00:20:40,003
be called is called pan.
叫做 pan

430
00:20:40,072 --> 00:20:44,041
And it has one argument, whose external name is recognizer:
有一个参数，实参标签是 recognizer

431
00:20:44,110 --> 00:20:45,876
that's what that means.
这就是这段代码的意思

432
00:20:45,945 --> 00:20:49,980
The ViewController., means that method is in myself.
ViewController. 表示这个方法是这个类里的

433
00:20:50,049 --> 00:20:52,650
If it was in my view it would probably be like
如果是视图类的某个方法，那就因该是

434
00:20:52,718 --> 00:20:54,752
PannableView.whatever.
PannableView.方法名

435
00:20:54,820 --> 00:20:58,055
This could also be self.pan, that's allowed,
这里写 self.pan 也是可以的

436
00:20:58,124 --> 00:21:01,658
saying pan.panGesture, pan recognizer in myself.
使用 self 的 pan(recognizer:)

437
00:21:01,727 --> 00:21:04,562
Also you could omit it, that part in totally and
你也可以完全忽略这一部分

438
00:21:04,630 --> 00:21:07,764
just say panRecognizer: because the default is for
就说 pan(recognizer:)，因为默认

439
00:21:07,833 --> 00:21:08,933
it to be in myself.
就是自己这个类里的

440
00:21:09,001 --> 00:21:11,668
So there's three ways I could have specified that,
所以有三种方法来指定

441
00:21:11,737 --> 00:21:15,239
ViewController.pan, self.pan, or just pan.
ViewController.pan, self.pan 或只是 pan

442
00:21:15,307 --> 00:21:17,674
But notice it does have that argument by the way,
但要注意它是有参数的

443
00:21:17,743 --> 00:21:20,678
that argument is gonna be the recognizer passed back to me.
那个参数就是手势识别器

444
00:21:20,746 --> 00:21:23,347
So when the pan starts to be recognized, it's gonna call
每当识别到拖动手势，就会调用这个方法

445
00:21:23,416 --> 00:21:26,150
this method, and that recognizer is gonna be passed.
然后手势识别器会被传给我

446
00:21:26,218 --> 00:21:29,220
This pan gesture recognizer called panGestureRecognizer
这个拖动手势识别器 panGestureRecognizer

447
00:21:29,288 --> 00:21:32,289
right there, that's gonna be passed back to me each time.
就是这个每次都会被传回来

448
00:21:32,358 --> 00:21:35,325
Now I've got a gesture recognizer for
我现在有了识别拖动的手势识别器

449
00:21:35,394 --> 00:21:38,162
panning, I just add it to the view,
我就把它添加给视图

450
00:21:38,231 --> 00:21:42,599
only views are capable of recognizing gestures.
只有视图能够识别手势

451
00:21:42,668 --> 00:21:44,768
So if you have a gesture recognizer,
如果你有一个手势识别器

452
00:21:44,837 --> 00:21:48,339
the only addGestureRecognizer method in the entire UIKit is
UIKit 里 addGestureRecognizer 这个方法

453
00:21:48,408 --> 00:21:51,108
in UIView, so you have to send it to UIView, or
只有 UIView 有。所以只能发送给 UIView

454
00:21:51,176 --> 00:21:52,576
a subclass of UIView.
或是 UIView 的子类

455
00:21:53,946 --> 00:21:56,880
Let's talk about the handling, so now this is code,
接着我们讲实际的处理。我们这里的代码

456
00:21:56,949 --> 00:21:57,948
adds the handler so
是添加负责处理事件的对象

457
00:21:58,017 --> 00:22:01,685
that the view is gonna start looking for pan gestures.
然后视图就开始识别拖动手势

458
00:22:01,754 --> 00:22:03,053
And then when it finds them,
每当识别到的时候

459
00:22:03,122 --> 00:22:06,189
it's going to start calling this pan recognizer.
就会调用 pan(recognizer:)

460
00:22:06,258 --> 00:22:08,025
Now before we can look at the code for
在讲代码之前

461
00:22:08,094 --> 00:22:10,861
that we gotta understand a few things about it.
我们需要先理解一些内容

462
00:22:10,930 --> 00:22:13,830
One is that when you get a gesture like a pan or
一个是当你得到一个手势识别器

463
00:22:13,899 --> 00:22:18,034
a pinch you need some concrete subclass specific information
比如拖动或缩放，你需要某些子类提供的属性

464
00:22:18,103 --> 00:22:19,403
about it like a pan.
比如对于拖动

465
00:22:19,472 --> 00:22:21,638
You gotta know where it is, or a pinch,
你需要知道拖到了哪里；对于缩放

466
00:22:21,707 --> 00:22:23,974
you gotta know much you pinched.
你需要知道缩放了多少

467
00:22:24,043 --> 00:22:26,944
So we have to understand what that means,
我展开讲讲这是什么意思

468
00:22:27,012 --> 00:22:30,681
now for a pan gesture recognizer, there are three.
对于 UIPanGestureRecognizer，有三个方法

469
00:22:30,749 --> 00:22:33,383
It's actually a little more, but there's this three very
实际上有更多的方法，但这三个

470
00:22:33,452 --> 00:22:36,086
important pieces of concrete information about the pan.
是有关拖动最重要的信息

471
00:22:36,155 --> 00:22:40,524
So, translation(in: UIView) is a function in the pan gesture
一个是 translation(in: UIView) 是它的一个方法

472
00:22:40,593 --> 00:22:42,793
recognizer where you can ask it,
你可以问 UIPanGestureRecognizer 的实例

473
00:22:42,861 --> 00:22:46,296
how far has this pan moved since it started.
从一开始共移动了多远

474
00:22:46,365 --> 00:22:49,466
How far has it moved from the start as I'm moving around,
从我开始到处拖动，一共移动了多远

475
00:22:49,535 --> 00:22:52,369
x and y, it's a CGPoint, so it's giving me the x and
返回 CGPoint，包含 x 和 y 两个方向

476
00:22:52,438 --> 00:22:55,172
y where it's moved to since it started.
从一开始算的总位移

477
00:22:55,240 --> 00:22:58,408
Velocity says how fast is the finger moving.
velocity 告诉我移动的速度

478
00:22:58,477 --> 00:23:00,077
Is it kind of whipping it around or
是很快速地在屏幕上划

479
00:23:00,146 --> 00:23:01,312
is it going really slow?
还是只是慢慢地移动？

480
00:23:01,380 --> 00:23:02,913
Because if it's going really slow,
因为如果移动地很慢

481
00:23:02,981 --> 00:23:05,348
maybe you wanna do a very you know, small drawing.
你需要绘制的内容就很少

482
00:23:05,417 --> 00:23:06,683
And if he's whipping it really fast and
如果划地很快

483
00:23:06,752 --> 00:23:08,818
you just wanna you know, moves something around, who knows?
你可能需要很快地更新

484
00:23:08,887 --> 00:23:11,221
And then there's setTranslation,
最后是 setTranslation

485
00:23:11,290 --> 00:23:13,724
now this last one is kinda cool because
这最后一个很实用

486
00:23:13,792 --> 00:23:17,027
if you just know the start point and where it's moved to.
因为如果你只知道它的起始位置和移动到的位置

487
00:23:17,096 --> 00:23:20,397
You're not really getting the incremental move with
你每次得到的都不是增量

488
00:23:20,465 --> 00:23:21,832
each time you update,
每次更新都是从一开始算的

489
00:23:21,900 --> 00:23:24,968
so you can actually set that translation to zero.
如果你能够把位移重置为零

490
00:23:25,037 --> 00:23:27,404
And then instead of getting the distance from the origin,
而不是从一开始的位移

491
00:23:27,473 --> 00:23:29,606
you're getting from the distance from the last time
你到的是相对于上一次更新的位移

492
00:23:29,674 --> 00:23:30,508
this was sent to you.
发送给你的是这个信息

493
00:23:30,576 --> 00:23:33,043
Cuz this handler's going to be sent to you over and
因为每次发给你的都是同一个识别器

494
00:23:33,112 --> 00:23:35,513
over as the pan moves around repeatedly.
到处拖动的时候都在重复这个操作

495
00:23:35,581 --> 00:23:38,248
Hundreds of times as you move around, so
一般都会有上百次

496
00:23:38,317 --> 00:23:41,651
often you'll wanna set that translation back to zero,
所以一般你都想把它重置为零

497
00:23:41,720 --> 00:23:44,421
it gives you incremental panning.
以此得到拖动的增量

498
00:23:44,490 --> 00:23:46,890
You'll see that with some of the other concrete
这个方法在其他的一些子类里也有

499
00:23:46,959 --> 00:23:48,408
Now, the abstract superclass, the UIGestureRecognizer,
抽象的 UIGestureRecognizer

500
00:23:48,409 --> 00:23:49,858
ones as well.
这个类

501
00:23:49,928 --> 00:23:52,729
even though you don't make one it still is the superclass of
虽然你不会去构造它，但作为父类

502
00:23:52,798 --> 00:23:53,463
these things.
这些子类

503
00:23:53,532 --> 00:23:54,631
And you do inherit,
都会继承

504
00:23:54,700 --> 00:23:58,969
especially this one very important var, Called state.
特别是这个重要的变量：state

505
00:23:59,037 --> 00:24:01,504
And a state tells you the state of the gesture's,
state 会告诉你手势的状态

506
00:24:01,573 --> 00:24:03,273
how it's being recognized.
它被识别为什么状态

507
00:24:03,342 --> 00:24:05,875
So all of these gesture recognizers start out in
所有的识别器都从

508
00:24:05,944 --> 00:24:07,845
the state possible.
.possible 这个状态开始

509
00:24:07,914 --> 00:24:10,614
It's possible this gesture could happen.
意味着这个手势可能会发生

510
00:24:10,683 --> 00:24:13,917
And then, once it starts if it's a continuous gesture
接着，如果是连续的手势

511
00:24:13,986 --> 00:24:16,687
like a pan or a pinch you go to the state began.
比如拖动或是缩放，你会进入 .began 的状态

512
00:24:16,756 --> 00:24:19,789
So this isn't like, " a pan!, I think it's started".
意味着拖动开始了

513
00:24:19,858 --> 00:24:22,392
So you'll get your handlers called and you can look at
识别器会调用负责处理的函数，你可以看到

514
00:24:22,461 --> 00:24:25,195
the state of the recognizer and say, it began.
识别器的状态变为了 .began

515
00:24:25,264 --> 00:24:28,031
And then, every time the finger moves,
之后每次手指移动了

516
00:24:28,100 --> 00:24:28,832
it's gonna get changed.
状态就会变为 .changed

517
00:24:28,901 --> 00:24:31,001
It gets change, change, change, change, change,
状态会一直是 .changed

518
00:24:31,069 --> 00:24:31,769
change, change.
如此持续一段时间

519
00:24:31,837 --> 00:24:34,071
You're getting your handler called repeatedly and
处理的函数会被重复调用

520
00:24:34,140 --> 00:24:36,473
you know anything that's changing is those methods above,
上面几个方法都发生改变了

521
00:24:36,542 --> 00:24:38,609
translation. And also the state.
位移

522
00:24:38,677 --> 00:24:39,343
Moves to change.
状态是 .changed

523
00:24:39,411 --> 00:24:42,045
And then, when the finger goes up, you get ended.
最后，手指抬起来了，状态变为终止了

524
00:24:42,114 --> 00:24:45,348
You'll get your handler called and the state will be ended.
负责处理的函数被调用，state 是 .ended

525
00:24:45,417 --> 00:24:50,254
Now, for a discrete gesture like a swipe,
对于相对独立的手势，比如轻扫

526
00:24:50,323 --> 00:24:52,189
a swipe either happened or not.
只会是发生或没有发生

527
00:24:52,257 --> 00:24:54,157
When you're looking at a swipe you don't get
当你处理轻扫的时候

528
00:24:54,226 --> 00:24:56,893
the swipe started and it's moving across the screen and
你不会得到说 .start 然后移动

529
00:24:56,962 --> 00:24:58,094
it comes off, no.
最后抬起来了。是不会这样的

530
00:24:58,163 --> 00:24:59,396
Either the swipe happened or not.
只会是发生了或没有发生

531
00:24:59,465 --> 00:25:01,297
So you would just get called once and
所以你只需要处理一次

532
00:25:01,366 --> 00:25:04,501
the stage is gonna go straight to being ended or recognized.
状态会直接是 recognized，代表识别到了

533
00:25:04,570 --> 00:25:09,273
But you have to be a little bit careful of the states
但对于状态你需要注意的是

534
00:25:09,341 --> 00:25:12,643
failed and cancelled.
.failed 和 .cancelled 两个状态

535
00:25:12,711 --> 00:25:15,212
Failed might be because you started a gesture and
.failed，失败了，可能是开始了某个手势

536
00:25:15,280 --> 00:25:16,647
then the system realized, my gosh,
突然系统意识到了，糟糕

537
00:25:16,715 --> 00:25:19,749
that wasn't a pan gesture, that was the start of a swipe.
其实那不是拖动，那是刚开始轻扫

538
00:25:19,818 --> 00:25:20,984
Or something like that.
或这一类的

539
00:25:21,053 --> 00:25:23,286
And so, it switches to a swipe.
所以最终识别为了轻扫

540
00:25:23,355 --> 00:25:26,623
So you could have canceled, and then the other one,
另外一个 .cancelled，取消了

541
00:25:26,692 --> 00:25:29,526
or the failed, and then you also didn't have canceled.
不同于失败，这个是取消了


542
00:25:29,595 --> 00:25:32,429
You're in the middle of panning, phone call comes in,
你可能还在拖动，但是突然有人打电话

543
00:25:32,498 --> 00:25:35,666
takes over your screen, person says, hello, how you doing?
切换到打电话的界面，问你过得怎么样

544
00:25:35,734 --> 00:25:39,102
Well, clearly, that pan gesture was canceled.
很显然地，拖动手势就取消了

545
00:25:39,171 --> 00:25:40,437
So you could get that, as well.
这也是可能发生的

546
00:25:40,505 --> 00:25:42,973
So if you ever do anything, when you gesture ends,
所以如果你需要在手势结束后进行处理

547
00:25:43,042 --> 00:25:45,709
then you have to be careful to clean up when it fails, or
那你需要处理好失败

548
00:25:45,778 --> 00:25:47,010
gets canceled, as well.
或是取消的情况

549
00:25:47,079 --> 00:25:48,946
So that's the state.
这就是 state

550
00:25:49,014 --> 00:25:52,549
So let's take a look then, knowing what we know about pan
在了解了拖动手势之后

551
00:25:52,618 --> 00:25:54,684
gestures, what the handler would look like.
我们来看看处理的函数是什么样的

552
00:25:54,753 --> 00:25:57,521
So remember that the handler is called pan,
还记得它叫做 pan

553
00:25:57,590 --> 00:25:59,990
recognizer is the argument there, and that is the pan
有个叫做 recognizer 的参数

554
00:26:00,058 --> 00:26:02,425
gesture recognizer itself coming back to us.
就是传回我们添加的 panGestureRecognizer

555
00:26:02,494 --> 00:26:04,194
And its state will be different,
状态取决于具体的情况

556
00:26:04,263 --> 00:26:06,329
and we can ask it about translation and view and
我们能从它得到视图里的位移

557
00:26:06,398 --> 00:26:07,497
all those things.
和其他的信息

558
00:26:07,566 --> 00:26:10,668
So the first thing we're gonna do is look at that state and
我们先判断 recognizer 的状态

559
00:26:10,736 --> 00:26:13,436
I'm going to do the same thing whether the pan is,
对于拖动的状态是

560
00:26:13,505 --> 00:26:15,839
has changed or whether the finger went up.
.changed 和 .ended

561
00:26:15,908 --> 00:26:17,407
That's kinda the last position of the pan,
也就是手指抬起来的最后时刻

562
00:26:17,476 --> 00:26:19,242
we're gonna do the exact same thing.
我要做的是同一件事情

563
00:26:19,311 --> 00:26:22,179
Notice by the way I'm using this switch thing fallthrough,
注意我 switch 里用了 fallthrough

564
00:26:22,247 --> 00:26:24,214
hopefully you got that in your reading assignment.
希望你们在做阅读作业的时候已经理解了

565
00:26:24,282 --> 00:26:27,584
That basically just means that you wanna fall through to
意思就是你想要落到下面那个分支

566
00:26:27,653 --> 00:26:30,587
the next case cuz in a lot of languages that's the default,
很多语言贯穿是默认的

567
00:26:30,655 --> 00:26:32,022
but in Swift it's not the default,
但是 Swift 里默认不会

568
00:26:32,091 --> 00:26:33,223
you don't fall through.
不会贯穿到下一分支

569
00:26:33,292 --> 00:26:34,791
So fallthrough makes you fall through,
所以用 fallthrough 来实现贯穿

570
00:26:34,860 --> 00:26:36,359
it's a special key word.
fallthrough 个关键字

571
00:26:36,428 --> 00:26:39,863
You could also say case.changed, .ended: that
当然你可以用 case .changed, .ended:

572
00:26:39,931 --> 00:26:41,397
would probably be actually better.
其实这样更好

573
00:26:41,466 --> 00:26:42,299
We'll do that in the demo.
我们在演示里也会这么做

574
00:26:44,069 --> 00:26:48,072
So if the pan moves a little or it ends, then I'm going to
如果移动了一段距离或是结束了

575
00:26:48,140 --> 00:26:52,676
get the translation from where we started at first
我都去获得从起点算的位移

576
00:26:52,745 --> 00:26:55,479
by asking for the translation in the pannable view.
通过 translation(in: pannableView) 实现

577
00:26:55,548 --> 00:26:57,815
That's the view the pan is having there.
也就是被拖动的视图

578
00:26:57,883 --> 00:26:58,949
You're almost always gonna ask for
你一般都是询问

579
00:26:59,018 --> 00:27:00,718
the translation in the pannable view.
在被拖动视图里的位移

580
00:27:00,786 --> 00:27:02,185
But you could ask for it in other views and
但你也可以得到在其他视图里的位移

581
00:27:02,254 --> 00:27:05,388
it will convert to that view's coordinate system if you want.
它会帮你转换到那个视图的坐标系统计算

582
00:27:05,457 --> 00:27:07,190
But almost always you're asking for
但我们几乎还是计算

583
00:27:07,259 --> 00:27:09,259
the one in the pannable view.
在被拖动视图里的位移

584
00:27:09,328 --> 00:27:11,695
Then, I'm gonna take that translation that I'm gonna
接着，我拿到了位移

585
00:27:11,764 --> 00:27:14,164
move and I'm gonna go do something with my app.
就可以用它来完成些操作

586
00:27:14,232 --> 00:27:14,965
Draw a line to,
画一条线到那里

587
00:27:15,033 --> 00:27:17,267
if I'm tracking the finger with the line, or
如果我是在跟踪手指的轨迹

588
00:27:17,336 --> 00:27:18,702
if I'm moving something,
或者如果我在移动某个东西

589
00:27:18,770 --> 00:27:21,104
I'm gonna move the thing to the new position.
我就需要移动到新的位置

590
00:27:21,173 --> 00:27:23,974
Then, if I want, I can set translation to zero so
如果我想的话，就把位移重置为零

591
00:27:24,043 --> 00:27:26,243
the next time this handler is called,
这样下一次调用的时候

592
00:27:26,311 --> 00:27:29,179
the translation is gonna be just the distance from
位移就会是相对于

593
00:27:29,248 --> 00:27:31,782
the last time it was called.
上一次时候的距离了

594
00:27:31,851 --> 00:27:33,717
As opposed to the distance from where it all started.
而不是从最开始计算的距离

595
00:27:35,053 --> 00:27:36,352
Where the pan started.
不是从拖动最开始的地方

596
00:27:36,421 --> 00:27:38,454
So that's it.
好，就是这样

597
00:27:38,523 --> 00:27:40,090
That's how a handler works, it's easy.
很简单，就是这么处理的

598
00:27:40,158 --> 00:27:42,126
Let's talk a little bit about some of the other concrete
让我们看看其他具体的手势识别器

599
00:27:42,194 --> 00:27:46,163
gestures. There is pinching, pinching is going to do with the scale.
比如 Pinch（捏合），它是用来缩放的手势

600
00:27:46,232 --> 00:27:48,932
So I put my fingers down, two fingers on the screen.
我把两只手指放到屏幕上

601
00:27:49,000 --> 00:27:50,968
Now, the scale is 1.0.
假定现在缩放比为 1.0

602
00:27:51,037 --> 00:27:53,370
If I put my fingers twice as far apart,
如果我把手指分开到原来两倍的距离

603
00:27:53,438 --> 00:27:54,971
now the scale is 2.0.
缩放比就变成了 2.0

604
00:27:55,040 --> 00:27:58,108
If I go down to half as small now, the scale is 0.5.
如果我缩小距离到原来的一半，缩放比就是 0.5

605
00:27:58,177 --> 00:27:59,876
So that's what pinch is doing.
这就是 Pinch（捏合）的效果

606
00:27:59,945 --> 00:28:02,179
It just constantly reporting what the scale is,
连续不断地报告相对于初始状态

607
00:28:02,247 --> 00:28:04,147
relative to what the pinch started.
当前的缩放比是多少

608
00:28:04,216 --> 00:28:06,482
Now, that scale is not read-only var, so
注意，scale 并不是一个只读变量

609
00:28:06,551 --> 00:28:07,884
you can reset it as well.
你也可以重置它

610
00:28:07,953 --> 00:28:10,587
And then, you'll get incremental scale.
这样你就能获得缩放的增量部分

611
00:28:10,655 --> 00:28:12,923
How much the scale has changed since the last time?
scale 相对于上次变化了多少

612
00:28:12,991 --> 00:28:16,693
There's almost like you keep resetting the initial finger
如果你每次都重置 scale 为 1

613
00:28:16,762 --> 00:28:19,663
down, to scale, if you set that scale to one.
效果就好像你在不断重复放下手指并进行缩放

614
00:28:19,732 --> 00:28:22,199
That's how you can get incremental scale.
以上说的是如何获得缩放的增量

615
00:28:22,267 --> 00:28:23,433
We'll do that in the demo as well.
我们会在 Demo 中演示这一点

616
00:28:23,502 --> 00:28:25,602
And then, you also get velocity.
然后，你还能获得它的速度

617
00:28:25,671 --> 00:28:29,839
How many points for a second or whatever this thing is, or
每秒变化了多少个“点”或者别的叫法也可以

618
00:28:29,908 --> 00:28:31,074
not really a point fact.
实际上不是“点”

619
00:28:31,143 --> 00:28:33,042
It's a scale factor.
而是缩放的因子

620
00:28:33,111 --> 00:28:34,478
The percent of scale is changing,
缩放变化的百分比

621
00:28:34,546 --> 00:28:36,046
how fast it's changing per second.
表达它每秒变化的快慢

622
00:28:36,114 --> 00:28:39,482
There's also a rotation gesture that's two fingers
还有一个 Rotation（旋转）手势

623
00:28:39,551 --> 00:28:41,452
down, like turning a knob.
用两只手指像拧门把手那样转动

624
00:28:43,522 --> 00:28:44,254
Keep the two fingers down.
放下两只手指

625
00:28:44,323 --> 00:28:44,921
You turn them.
转动它们

626
00:28:44,990 --> 00:28:46,690
You get the rotation there.
这样就完成了旋转手势

627
00:28:46,759 --> 00:28:48,492
The rotation is in radians.
旋转是按弧度算的

628
00:28:48,560 --> 00:28:51,161
Again, it's not read only so you could reset it and
和之前一样，这个也不是只读的

629
00:28:51,230 --> 00:28:53,263
get the incremental turning.
你可以通过重置它来获得增量部分

630
00:28:53,332 --> 00:28:55,432
And you also get the velocity in radians per second.
你也可以取得以弧度每秒为单位的速度

631
00:28:55,501 --> 00:28:57,501
How fast the person is turning their knob.
表达拧门把手这个动作有多快

632
00:28:57,569 --> 00:29:01,471
There's also SwipeGesture, and again this is discrete so
还有一个 Swipe（轻扫）手势，它是非连续的

633
00:29:01,540 --> 00:29:05,108
your handler's only gonna be called once.
当手势被识别出来的时候

634
00:29:05,177 --> 00:29:06,677
If it recognizes this gesture.
你的处理方法只会被调用一次

635
00:29:06,745 --> 00:29:07,777
Now, because of that,
因为这点

636
00:29:07,846 --> 00:29:10,213
you have to configure a SwipeGesture recognizer.
你必须事先设置好轻扫手势的识别器

637
00:29:10,282 --> 00:29:11,014
You create it and
创建它

638
00:29:11,082 --> 00:29:13,484
then you wanna set vars here like direction.
然后你可能想要设置一些变量，比如方向

639
00:29:13,552 --> 00:29:16,386
You wanna left swipe, right swipe, up, down.
上、下、左、右哪一个

640
00:29:16,454 --> 00:29:17,554
And how many fingers?
用多少手指？

641
00:29:17,623 --> 00:29:18,588
Two finger swipe?
两个手指扫

642
00:29:18,657 --> 00:29:20,324
Three finger swipe?
还是三个手指扫

643
00:29:20,392 --> 00:29:21,942
One finger swipe?
还是一个手指扫？

644
00:29:21,943 --> 00:29:23,493
You set all that up when you create it because then it's
在创建时就设置好所有这些

645
00:29:23,562 --> 00:29:24,728
just gonna be looking for that.
之后系统要做的只是查找符合设置的手势

646
00:29:24,796 --> 00:29:27,197
And when it finds it, it's gonna call your handler once.
一旦发现触发了这个手势，只会调用一次你的处理方法

647
00:29:27,266 --> 00:29:29,465
Cuz it's discrete.
因为它是非连续的

648
00:29:29,534 --> 00:29:32,001
Then there's tap gesture, similar to the swipe gesture
然后是 Tap（点击）手势，在你必须事先设置这点上

649
00:29:32,070 --> 00:29:33,137
in that you have to configure it.
它和轻扫手势类似

650
00:29:33,205 --> 00:29:35,639
Number of taps, like is it a double tap and
点击的次数，比如是不是双击

651
00:29:35,707 --> 00:29:38,275
is it two finger tap, you do that.
是不是要求两只手指点击

652
00:29:38,343 --> 00:29:41,711
And then, it's gonna call, this is not purely a discrete
然后它会被调用，它不是纯粹的非连续手势

653
00:29:41,780 --> 00:29:45,381
gesture, like SwipeGesture, really you're looking for
这点与轻扫手势不太一样

654
00:29:45,450 --> 00:29:48,685
the state ended with a tap as well, but
你也可以获知它结束的状态

655
00:29:48,753 --> 00:29:50,654
still you have to preconfigure it like a swipe, so
但是你还是要像轻扫手势那样事先设置

656
00:29:50,722 --> 00:29:53,490
it behaves almost exactly like a discrete gesture.
它表现上大体还是非连续的

657
00:29:55,260 --> 00:29:57,828
So hopefully this will make a lot more sense when we show in
希望这些解释可以在之后的 Demo 中变得更有意义 

658
00:29:57,896 --> 00:30:00,563
the demo here, our demo we're gonna add three gestures,
Demo 中会演示三种手势

659
00:30:00,632 --> 00:30:03,766
one is a pinch, that's just gonna make the face bigger and
其一是捏合，用来放大

660
00:30:03,835 --> 00:30:04,968
smaller.
或者缩小脸

661
00:30:04,969 --> 00:30:06,102
Which has nothing to do with a model that view only so
这和模型无关

662
00:30:06,172 --> 00:30:08,672
we're gonna put that handler in the view.
所以我们会把处理方法放在视图中

663
00:30:08,741 --> 00:30:13,176
And then, we gonna do pan, moving around.
然后我们还会加入拖动，用来移动它

664
00:30:13,245 --> 00:30:14,878
Actually no, we're gonna swipe instead of pan.
不对，我们要用轻扫代替拖动

665
00:30:14,946 --> 00:30:15,779
Let's use swipe.
我们还是用轻扫

666
00:30:15,847 --> 00:30:18,915
We do swipe and we swipe up to make our face happier or
我们向上轻扫，让脸变得更高兴

667
00:30:18,984 --> 00:30:20,183
swipe down to make it sadder.
向下轻扫，让脸变得更悲伤

668
00:30:20,252 --> 00:30:21,985
And we'll have tab to open and close your eyes.
我们用点击控制睁眼或闭眼

669
00:30:22,053 --> 00:30:23,153
How about that?
如何？

670
00:30:23,221 --> 00:30:25,388
And those last two are obviously gonna affect
显然后两个会影响模型

671
00:30:25,457 --> 00:30:28,458
the model, so the'll have to be handled by the controller.
所以我们应该在控制器中处理它们

672
00:30:28,527 --> 00:30:31,994
So le's go back to our code where we were here and
我们回到之前的代码中

673
00:30:32,063 --> 00:30:33,396
how we can do this.
我们要怎么做呢

674
00:30:33,465 --> 00:30:36,633
Le's do the pinch first.
我们先实现捏合

675
00:30:36,701 --> 00:30:39,469
Now, the pinch does't affect the model, so
捏合不影响模型

676
00:30:39,538 --> 00:30:40,837
it can be handled by the view.
它可以由视图处理

677
00:30:40,906 --> 00:30:42,839
So le's actually go over to our view and
我们切换到视图 

678
00:30:42,908 --> 00:30:48,044
start by writing a handler for a pinch.
首先写一个捏合的处理方法

679
00:30:48,113 --> 00:30:50,880
I'm gonna call this handler func changeScale because
我将这个处理方法命名为 changeScale

680
00:30:50,949 --> 00:30:53,683
that's what it's gonna do, it's gonna be a pinch.
因为这就是它要做的事情，它是捏合

681
00:30:53,752 --> 00:30:59,589
So it's gonna change the scale of our head.
它会改变头的大小

682
00:30:59,658 --> 00:31:05,796
And I'm gonna say byReactingTo a pinchRecognizer,
我把参数命名为 byReactingTo pinchRecognizer

683
00:31:05,864 --> 00:31:09,932
Which will be UI pinch recognizer,
它的类型是 UIPinchGestureRecognizer

684
00:31:10,001 --> 00:31:14,904
pinch gesture recognizer, there we go.
UIPinchGestureRecognizer，好了 

685
00:31:14,973 --> 00:31:17,440
So this is gonna be my handler.
这会是我的处理方法

686
00:31:17,509 --> 00:31:20,777
So it's gonna get this pinch sent back to me all the time.
它会不断的把捏合的数据发给我

687
00:31:20,846 --> 00:31:22,712
I'm gonna look at that pinch of scale to know
我会查看捏合的缩放

688
00:31:22,781 --> 00:31:24,714
how much to scale my own scale.
来决定我自己的缩放

689
00:31:24,783 --> 00:31:32,321
So I'm gonna switch on the pinch recognizer's state.
我要 swich pinchRecognizer.state

690
00:31:32,390 --> 00:31:35,358
Remember, it inherits that from UI gesture recognizer,
记住，state 继承自 UIGestureRecognizer

691
00:31:35,427 --> 00:31:37,560
which is the super class of this.
也就是它的父类

692
00:31:37,629 --> 00:31:40,696
And in the case that it is changed, so
我们用 case .changed

693
00:31:40,765 --> 00:31:42,532
the pinch has changed, or
表示这个捏合改变了

694
00:31:42,601 --> 00:31:46,869
if it's ended, which means the user lifted the fingers off.
还有 .ended，意味着用户把手指抬起

695
00:31:46,938 --> 00:31:51,307
Neither of those cases I'm gonna adjust my scale
这两种情况下，我都让自己的 scale

696
00:31:51,376 --> 00:31:54,344
by whatever the scale is of the pinchRecognizer.
跟随着 pinchRecognizer.scale 改变

697
00:31:56,548 --> 00:31:57,247
Simple as that.
很简单吧

698
00:31:59,518 --> 00:32:04,320
Now the thing about this though, what if
但是假设我从 1.0 倍开始

699
00:32:04,389 --> 00:32:08,425
I start my pinch here 1.0, and I move it just a little bit.
然后只移动一小点

700
00:32:08,494 --> 00:32:09,058
Okay, fine.
一切还算正常

701
00:32:09,127 --> 00:32:10,961
My scale gets moved just a little bit.
我的缩放只改变了一小点

702
00:32:11,030 --> 00:32:12,896
What if I moved all the way out to scale 2.0?
如果我继续扩大直到 2.0 倍

703
00:32:12,964 --> 00:32:14,764
Now my face gets 2.0.
现在脸变成了 2.0 倍大小

704
00:32:14,833 --> 00:32:17,634
Now what if I move it out to 2.1?
如果我继续扩大到 2.1 倍呢？

705
00:32:17,703 --> 00:32:23,373
This code's gonna make my face go from 2.1 to 4.2 you see.
这段代码会把脸从 2.1 倍变为 4.2 倍

706
00:32:23,442 --> 00:32:26,543
So I need to keep resetting this scale back to 1 all
所以我要不断重置 scale 为 1

707
00:32:26,611 --> 00:32:29,713
the time so I'm getting incremental scale changes.
这样我才能取得 scale 的增量

708
00:32:29,781 --> 00:32:32,949
So I'm gonna say pinch recognizer .scale = 1.
所以我要写 pinchRecognizer.scale = 1

709
00:32:33,017 --> 00:32:35,718
So I'm just constantly resetting.
这样就会不断地重置它

710
00:32:35,787 --> 00:32:37,687
Every time this gets called, and
每次这段代码被调用

711
00:32:37,756 --> 00:32:40,490
I move my scale up, I'm gonna reset the scale so
每次我扩大缩放倍数，我都会重置 scale

712
00:32:40,558 --> 00:32:43,426
that I'm starting at one again with my pinch.
这样捏合的 scale 再次从 1 开始

713
00:32:43,495 --> 00:32:46,963
That gives me incremental scaling there.
这样我就获得了 scale 的增量

714
00:32:47,031 --> 00:32:50,500
And of course we have to handle all the other cases
当然我还要处理

715
00:32:50,569 --> 00:32:51,300
of the state.
state 的其他 case

716
00:32:51,369 --> 00:32:52,302
But I'm not gonna do anything.
但是我不会做任何操作

717
00:32:52,370 --> 00:32:54,270
So I'm not gonna do anything when the pinch starts.
捏合的开始，我不会做任何事

718
00:32:54,339 --> 00:32:55,906
If it gets cancelled, I don't care.
它被取消了，我也不关心

719
00:32:55,975 --> 00:32:57,640
I'll just leave it whatever scale it was
这时不论 scale 是多少

720
00:32:57,709 --> 00:32:58,475
in at the time, etc.
都不用管它

721
00:32:58,543 --> 00:33:02,512
So I don't need to really handle any other cases.
其实我完全没必要处理其他 case

722
00:33:02,581 --> 00:33:03,146
So that's it.
这样就完成了

723
00:33:03,215 --> 00:33:06,849
The handlers are super easy to write.
处理方法写起来真的非常容易

724
00:33:06,918 --> 00:33:07,750
And this scale by the way,
这就是如何操作缩放

725
00:33:07,819 --> 00:33:10,420
everyone understands, is this scale right here, this bar.
操作缩放的这部分内容都明白了吗？

726
00:33:10,489 --> 00:33:11,521
This is our scale.
这就是关于 scale

727
00:33:14,025 --> 00:33:14,758
Questions about that?
有什么问题吗？

728
00:33:15,760 --> 00:33:16,793
So now we have a handler.
我们有了一个处理方法

729
00:33:16,862 --> 00:33:20,030
We have someone to handle when a pinch happens in the view.
意味着当捏合在这个视图内触发的时候有人来处理

730
00:33:20,098 --> 00:33:24,768
Now all we need to do is add a recognizer that recognizes
我们还需要最后一道工序，添加一个手势识别器

731
00:33:24,837 --> 00:33:27,070
a pinch, and calls the handler.
识别捏合并调用处理方法

732
00:33:27,139 --> 00:33:29,639
So we're gonna do that up here in our face view's
我们会在 faceView 的 didSet 中做这件事

733
00:33:29,707 --> 00:33:32,175
didSet, because this is the first time we got a hold of
因为这是我们最早能够控制 faceView 的地方

734
00:33:32,244 --> 00:33:34,777
that face view, and I want the face view to be the one
我希望 faceView

735
00:33:34,846 --> 00:33:37,681
that is recognizing this pinch.
能识别这个捏合

736
00:33:37,749 --> 00:33:40,583
So let's start by creating the handlers, so
让我们开始写处理方法

737
00:33:40,652 --> 00:33:42,618
I'm going to create a local variabilities to make it clear
我将要创建一个局部变量

738
00:33:42,687 --> 00:33:43,753
to my handler.
作为我的处理方法

739
00:33:43,822 --> 00:33:48,958
It's a hashtag selector and it's the faceView method,
它写作 #selector()，参数填入一个 FaceView 的方法

740
00:33:49,027 --> 00:33:52,429
changeScalebyReactingTo, that's my handler.
FaceView.changeScale(byReactingTo:)，这就是我的处理方法

741
00:33:54,266 --> 00:33:56,433
And then I am going to create a recognizer here,
然后我要在这创建一个识别器

742
00:33:56,501 --> 00:33:59,069
a pinch recognizer and
一个捏合识别器

743
00:33:59,138 --> 00:34:03,073
it's going to be a UIPinchGestureRecognizer and
它将会是一个 UIPinchGestureRecognizer

744
00:34:03,141 --> 00:34:05,641
of course we need the target and the action.
我们需要传入 target 和 acton

745
00:34:05,710 --> 00:34:07,744
That's all we need to create a recognizer.
这就是创建识别器的所有步骤

746
00:34:07,813 --> 00:34:10,714
The target is going to be the faceView,
target 传入 faceView

747
00:34:11,950 --> 00:34:14,083
it's gonna handle this thing itself, and
 faceView 它自己会处理这个手势

748
00:34:14,152 --> 00:34:15,786
the action is gonna be this handler.
action 传入刚刚创建的处理方法

749
00:34:18,890 --> 00:34:19,455
That's it.
这样就完成了

750
00:34:19,524 --> 00:34:21,991
Now we just need to take the faceView and
我们还需要调用 faceView 的方法

751
00:34:22,060 --> 00:34:25,628
add GestureRecognizer, the pinchRecognizer.
addGestureRecognizer(_:) 并传入 pinchRecognizer

752
00:34:25,697 --> 00:34:27,264
And by doing that,
做完这些之后

753
00:34:27,332 --> 00:34:29,899
face view is gonna start recognizing pinches.
faceView 就可以识别捏合了

754
00:34:29,967 --> 00:34:32,568
And when it recognizes one, it's gonna send this handler
当它识别到一个捏合时

755
00:34:32,637 --> 00:34:35,038
message right here to the face view.
它会调用 faceView 里的这个处理方法

756
00:34:35,107 --> 00:34:40,543
Now, if you
让我们试验下

757
00:34:40,611 --> 00:34:47,917
hope this is gonna work, let's see.
它能不能如预期的那样工作

758
00:34:47,986 --> 00:34:49,286
When you might ask, by the way,
对了，这时你们可能要问

759
00:34:49,354 --> 00:34:52,055
if I have a mouse here, how do I do a pinch?
我只有一个鼠标，怎么模拟捏合的动作？

760
00:34:52,124 --> 00:34:53,723
In my thing, okay?
这也正是我要说的

761
00:34:53,792 --> 00:34:55,858
Well the magic there is option.
要借助神奇的 option 键

762
00:34:55,927 --> 00:34:57,293
If you press option, and look,
如果按住 option，看

763
00:34:57,362 --> 00:34:58,662
I haven't even touched anything,
我还没碰任何其他东西

764
00:34:58,730 --> 00:35:00,763
see I have two things right there.
那里已经出现了两个圆圈

765
00:35:00,832 --> 00:35:02,065
And they kinda stay the same apart.
并且它们的中心点保持不变

766
00:35:02,134 --> 00:35:05,167
You can also do option shift, and they'll offset them, so
同时按住 option + shift，就能平移它们的中心点

767
00:35:05,236 --> 00:35:06,702
you can pinch anywhere you want.
所以你可以对任何区域模拟捏合

768
00:35:06,771 --> 00:35:09,539
So anyway, do that. Now, I'm gonna hold the mouse down and pinch
不多说了，我们赶快试一下。现在我要按住鼠标左键开始模拟捏合

769
00:35:10,908 --> 00:35:12,975
Oh! No, it's not working.
怎么回事！完全没效果

770
00:35:13,044 --> 00:35:15,812
See that? How could that possibly be?
看到了吗，为什么会这样呢？

771
00:35:15,881 --> 00:35:17,914
Well, let's take a moment here and debug this.
好吧，我们花点时间来调试这个问题

772
00:35:17,983 --> 00:35:19,482
Why would this not be working?
为什么没效果呢？

773
00:35:19,551 --> 00:35:20,750
I put that pinch gesture.
我创建了捏合手势

774
00:35:20,819 --> 00:35:21,818
I added it.
添加到视图上

775
00:35:21,887 --> 00:35:23,420
I have a handler.
我也有处理方法

776
00:35:23,489 --> 00:35:26,322
Let's start by going to our FaceView and
我们跳到 FaceView 中

777
00:35:26,391 --> 00:35:28,691
putting a break point right here in our handler.
在处理方法内部打一个断点

778
00:35:28,760 --> 00:35:31,394
And let's see if it's actually handling it okay.
让我们看看它是不是真的被调用了

779
00:35:31,463 --> 00:35:34,130
So I'm going to go back to here,
回到这里

780
00:35:34,199 --> 00:35:37,867
I'm going to get my option ready, pinch.
按住 option，然后模拟捏合

781
00:35:37,936 --> 00:35:38,835
Alright!
好

782
00:35:38,903 --> 00:35:40,169
It broke.
断住了

783
00:35:40,238 --> 00:35:43,339
It's definitely calling my handler.
确实调用了我的处理方法

784
00:35:43,407 --> 00:35:44,173
So what's the problem?
那么问题是什么？

785
00:35:44,242 --> 00:35:44,974
Let's try another thing.
我们试试另一个方法

786
00:35:45,043 --> 00:35:47,443
Let's say let's print our scale and
我们把 scale 的值 print 出来

787
00:35:47,512 --> 00:35:49,845
see if our scale is being change.
看看 scale 是不是不断变化

788
00:35:49,914 --> 00:35:51,447
I'm just gonna put a little print line in here.
我会在这里加一行 print

789
00:35:51,516 --> 00:35:53,717
Use a combination of break points here and
print 和断点结合使用

790
00:35:53,785 --> 00:35:55,952
doing print debugging.
来调试问题

791
00:35:56,020 --> 00:35:56,786
And let's,
接下来

792
00:35:56,854 --> 00:36:00,190
let's see if the scale is actually being changed.
我们看看 scale 到底是不是不断变化

793
00:36:03,662 --> 00:36:04,293
Here we go.
开始

794
00:36:04,362 --> 00:36:08,164
Again option key, and, it looks like it is.
再次按住 option 键，似乎是在改变

795
00:36:08,233 --> 00:36:09,666
I see something in the background there.
我看到了控制台输出了一些结果

796
00:36:10,602 --> 00:36:12,334
Sure enough look at that.
看到这些可以确定了

797
00:36:12,403 --> 00:36:15,739
Half, double, it's working perfectly.
一半，两倍，它完全能正确地工作

798
00:36:15,807 --> 00:36:17,373
Why is it not redrawing that face.
那么为什么脸没有重绘呢

799
00:36:17,442 --> 00:36:20,076
Can anyone think why it's not redrawing.
谁知道它为什么没重绘

800
00:36:21,279 --> 00:36:22,179
Cuz we know it's working.
我们知道刚刚那部分都没问题

801
00:36:24,049 --> 00:36:29,052
It's because when you change a var, like scale, right
这是因为当我们改变一个像 scale 这样的变量的值时

802
00:36:29,120 --> 00:36:34,391
here it does not automatically know to redraw your view.
系统不会自动帮你重绘视图

803
00:36:35,394 --> 00:36:36,993
That scale is changing fine.
scale 改变得很正常

804
00:36:37,062 --> 00:36:39,462
But the last time draw was called was when this first
但是上一次绘制实际上就是最初的那次绘制

805
00:36:39,530 --> 00:36:42,231
thing was drawn, you know, this method we have down here
你们知道的，就是下面这个方法

806
00:36:42,300 --> 00:36:44,901
in the FaceView called draw CGRect.
FaceView 中的 draw(_ rect: CGRect)

807
00:36:44,970 --> 00:36:45,668
This thing?
就是它

808
00:36:45,737 --> 00:36:47,503
This was called when it was first drawn and
它在第一次绘制时被调用

809
00:36:47,572 --> 00:36:49,406
it's never been called again.
之后就再也不会被调用了

810
00:36:49,474 --> 00:36:54,010
So without this being called there's no other way to draw
如果不调用这个方法，我们就没有其他的办法绘制了

811
00:36:54,079 --> 00:36:57,446
my face I told you this is the only way to draw.
我告诉过你们，这个方法是唯一可以完成绘制的

812
00:36:57,515 --> 00:37:00,783
So we have to get this to get called.
我们必须让这个方法被调用

813
00:37:00,852 --> 00:37:02,185
And how are we gonna do that?
应该怎么做呢？

814
00:37:02,253 --> 00:37:05,355
Well we're just gonna slide right up here to scale, and
我们回到上面 scale 的地方

815
00:37:05,423 --> 00:37:09,292
any time scale get called, we're gonna do a didSet.
每次 scale 被改变，我们应该加上一个 didSet

816
00:37:10,395 --> 00:37:12,795
Okay, and inside here we're going to
在这里

817
00:37:12,864 --> 00:37:14,631
cause ourself to get drawn.
我们要让视图绘制自身

818
00:37:14,699 --> 00:37:15,331
Now how do I do that?
现在应该怎么做？

819
00:37:15,400 --> 00:37:17,701
Do I call draw like that?
我可以直接调用 draw() 吗？

820
00:37:19,904 --> 00:37:22,204
No, I see a lot of shaking heads no and absolutely not.
我看到许多人摇头了，答案是绝对不能

821
00:37:22,273 --> 00:37:23,940
Of course we never call draw.
当然我们不能调用 draw()

822
00:37:24,008 --> 00:37:26,375
We get huge trouble if we do that.
那样做会产生巨大的问题

823
00:37:26,444 --> 00:37:27,376
What do we call instead?
有什么替代方案呢？

824
00:37:27,445 --> 00:37:28,645
Anyone remember from the slides?
之前的幻灯片提到过，有人还记得吗？

825
00:37:30,915 --> 00:37:32,048
SetNeedsDisplay.
是 setNeedsDisplay()

826
00:37:33,684 --> 00:37:36,152
So we're telling the system something about us has
这样做相当于告诉系统“我们这里有东西改变了”

827
00:37:36,221 --> 00:37:38,455
changed, we need to be re-displayed.
“我们要被重绘”

828
00:37:38,523 --> 00:37:41,924
So please, at your earliest convenience, re-display us.
“所以请你尽快重绘我们”

829
00:37:41,993 --> 00:37:42,658
And that's what it's gonna do.
以上就是它要做的

830
00:37:42,727 --> 00:37:46,830
And in fact, we want this on all of our things here.
实际上我们希望把这个行为加到这里所有的变量上

831
00:37:50,569 --> 00:37:54,204
Any time any of these public things get changed by someone,
不论何时，只要这些公开的变量被外界改变了

832
00:37:54,272 --> 00:37:55,805
we want to re-display.
我们都希望进行重绘

833
00:37:55,874 --> 00:37:58,074
Let's put this comment up here.
把这段注释上移一下放在这里

834
00:37:58,143 --> 00:38:00,910
So this is very common to have this little snippet of code
这段代码经常跟在这样的变量后面

835
00:38:00,979 --> 00:38:03,746
after any var, that when you change it,
当你改变它时

836
00:38:03,815 --> 00:38:05,315
would change the way things look.
会导致视图的外观也随之改变

837
00:38:06,684 --> 00:38:08,518
Now when we run we can actually go back here and
我们运行之前，回到这里

838
00:38:08,586 --> 00:38:09,652
get rid of this print.
不再需要这个 print 了

839
00:38:09,720 --> 00:38:15,525
Pretty confident it's
我有足够的把握

840
00:38:15,594 --> 00:38:20,629
going to work now.
现在可以正常工作了

841
00:38:20,698 --> 00:38:24,567
Here I go on option again, and sure enough, look, our scale.
我再次按住 option 键，非常确信，看

842
00:38:24,636 --> 00:38:27,703
Since our scale changes here, that setNeedsDisplay is
只要 scale 改变，setNeedsDisplay 就被调用

843
00:38:27,772 --> 00:38:30,740
asking to draw and iOS is accommodating us by drawing.
请求系统进行绘制，系统也很乐意地帮了我们

844
00:38:33,378 --> 00:38:34,143
That's pretty cool,
这真的很酷

845
00:38:34,211 --> 00:38:37,413
that was quite simple to put in that gesture to do that.
加入这样一个手势还是相当简单的

846
00:38:37,482 --> 00:38:40,082
So let's go back now to our controller, and
让我们回到控制器中

847
00:38:40,151 --> 00:38:45,021
think about doing a gesture like a tap, to open the eyes.
考虑如何添加一个点击手势，控制眼睛的睁闭

848
00:38:45,089 --> 00:38:48,391
Now again, the view could be the handler for that.
再次，虽然视图能够处理这个手势

849
00:38:48,460 --> 00:38:50,260
It arguably knows how to open an close its eyes.
视图本身最知道应该如何睁闭它自己的眼睛

850
00:38:50,328 --> 00:38:53,229
But if we made the view be the handler for a tap, and it
但是如果我们让视图处理点击

851
00:38:53,298 --> 00:38:56,866
opened the eyes, it would get out of sync with the model.
眼睛睁开了，但是模型和视图之间没有得到同步

852
00:38:56,935 --> 00:38:59,569
Cuz the model is what says whether the eyes are open,
因为模型中定义了眼睛是否是睁开的

853
00:38:59,638 --> 00:39:00,303
not the face view.
而 FaceView 中没有

854
00:39:00,371 --> 00:39:01,770
Face view is a slave.
FaceView 只是苦力

855
00:39:01,839 --> 00:39:03,205
It's a minion of the controller,
是控制器的下属

856
00:39:03,274 --> 00:39:04,907
it's supposed to do what the controller wants, so
控制器要它做什么，它就应该做什么

857
00:39:04,976 --> 00:39:05,642
we can't do that.
所以这件事不能让它做

858
00:39:05,710 --> 00:39:08,678
So we're gonna have to have the controller handle a tap,
所以我们不得不让控制器来处理点击

859
00:39:08,747 --> 00:39:09,712
and change it in the model.
同时改变模型中的数据

860
00:39:09,781 --> 00:39:12,248
And then it'll automatically
因为那行代码的存在

861
00:39:12,317 --> 00:39:15,384
update in the UI because of this line of code right here.
它会自动地更新界面

862
00:39:15,453 --> 00:39:19,055
Any time we change our model it's gonna update our UI.
任何时候我们改变了模型，界面就会跟着更新

863
00:39:19,124 --> 00:39:21,624
So we're gonna just have to have a handler for
所以我们必须实现一个点击的处理方法

864
00:39:21,693 --> 00:39:24,193
tap that just changes our model.
它的任务仅仅是改变模型

865
00:39:24,262 --> 00:39:26,296
And that's all it needs to do.
无需关心其他事情

866
00:39:27,832 --> 00:39:29,332
Let's try that handler first.
让我们先尝试实现处理方法

867
00:39:29,400 --> 00:39:32,702
Let's call that handler, how about toggleEyes
我们先为它命名，叫做 toggleEyes 怎么样

868
00:39:32,770 --> 00:39:34,671
cuz we're gonna tap and it's gonna with the eyes.
因为我们要进行点击，这个行为会作用于眼睛

869
00:39:34,739 --> 00:39:37,206
If its opened it'll close, close it'll open.
如果眼睛是闭着的，会睁开，反之亦然

870
00:39:37,275 --> 00:39:42,345
And toggleEyes is a tapGestureRecognizer thing,
并且 toggleEyes 要处理的是一个 UITapGestureRecognizer

871
00:39:42,414 --> 00:39:47,016
so I'm gonna say byReacting to a tapRecognizer
所以我跟一个参数叫做 byReactingTo tapRecognizer

872
00:39:47,085 --> 00:39:51,254
which is a type UITapGestureRecognizer.
它的类型是 UITapGestureRecognizer

873
00:39:51,323 --> 00:39:53,356
And here I'm just gonna say,
它的内部我要写

874
00:39:53,425 --> 00:39:56,625
if the tapRecognizer.state is ended.
if tapRecognizer.state == .ended

875
00:39:56,694 --> 00:39:58,194
So the tap happened.
说明点击发生了

876
00:39:58,262 --> 00:40:03,066
Then I'm gonna let eyes, which is FacialExpression.Eyes,
然后 let eyes: FacialExpression.Eyes

877
00:40:03,135 --> 00:40:06,135
just so that you know what type that is,
这样你就知道它的类型了

878
00:40:06,204 --> 00:40:10,206
equal whatever my current expression's eyes are,
不管当前的 expression.eyes 是什么

879
00:40:10,275 --> 00:40:14,810
if the current expressions eyes are closed, then I'm
如果当前的 eyes 是 closed 的

880
00:40:14,879 --> 00:40:19,448
going to have them be open, otherwise they will be closed.
就让它等于 open，反之则是 closed

881
00:40:19,517 --> 00:40:21,251
So I'm just toggling them.
我只是在切换它的状态

882
00:40:22,754 --> 00:40:27,323
So eyes now which is of type FacialExpression.Eyes,
所以类型为 FacialExpression.Eyes 的 eyes

883
00:40:27,391 --> 00:40:30,592
it's got the opposite or whatever the old one had.
不论之前是什么，取与之相反的那个

884
00:40:30,661 --> 00:40:35,365
Now, I'm gonna set my model to equal a new facial expression.
现在我要对这个模型赋予一个新的 FacialExpression

885
00:40:35,433 --> 00:40:36,766
That new facial expression's eyes
新的表情中的 eyes

886
00:40:36,835 --> 00:40:39,768
are gonna be this new eyes I just calculated.
将会是经过刚才计算得到的新的 eyes

887
00:40:39,837 --> 00:40:42,104
And the mouth is gonna be whatever the old mouth was.
而 mouth 还保持原来的状态

888
00:40:42,173 --> 00:40:44,874
I'm not doing anything to the mouth, so I'm just gonna say
我不会对 mouth 做任何改变

889
00:40:44,942 --> 00:40:47,376
expression.mouth, for the old one.
只需传入旧的 expression.mouth

890
00:40:47,445 --> 00:40:49,278
So here I'm changing my model and
以上就是我改变模型的过程

891
00:40:49,347 --> 00:40:51,380
that's gonna cause this didSet to happen.
这将会触发 didSet

892
00:40:51,449 --> 00:40:53,082
It's gonna re-draw my view and
它将会重绘我的视图

893
00:40:53,151 --> 00:40:55,318
the eyes are gonna be the opposite of what they were.
眼睛将会是和之前相反的状态

894
00:40:57,421 --> 00:40:58,821
So that's the handler.
以上就是这个处理方法

895
00:40:58,890 --> 00:40:59,489
That's gonna handle that.
它将会处理点击

896
00:40:59,558 --> 00:41:02,825
So now we have to add a tap gesture recognizer
我们还要向我们的 FaceView 中

897
00:41:02,894 --> 00:41:03,692
to our face view.
添加一个点击手势识别器

898
00:41:03,761 --> 00:41:08,064
So this time let's just say let tapRecognizer =
这次我们直接写

899
00:41:08,133 --> 00:41:10,600
UITapGestureRecognizer.
let tapRecognizer = UITapGestureRecognizer(target:action:)

900
00:41:10,668 --> 00:41:13,703
And as always we just specify target and selector.
和往常一样我们要指定 target 和 selector

901
00:41:13,772 --> 00:41:15,838
So the target this time is not faceView,
这次 target 不是 faceView

902
00:41:15,907 --> 00:41:17,139
up here it was faceView.
虽然上一个是 faceView

903
00:41:17,208 --> 00:41:19,542
Now the target is myself.
但是这次是控制器自身

904
00:41:19,611 --> 00:41:22,644
And the action is going to be,
action 将会是

905
00:41:22,713 --> 00:41:24,547
again I can say faceView controller or
当前这个 FaceViewController

906
00:41:24,616 --> 00:41:28,751
I can indicate self dot, we'll do that, toggle eyes.
我可以写 self.toggleEyes(byReactingTo:)

907
00:41:33,592 --> 00:41:36,825
And we need to put around this #selector.
而且需要用 #selector() 括起来

908
00:41:36,894 --> 00:41:41,397
Cuz we need to turn it into that particular selector.
因为我们需要将它转化为指定的 selector

909
00:41:41,466 --> 00:41:43,966
Then again, I don't actually need that self in there,
然后，这里实际上不需要写 self

910
00:41:44,034 --> 00:41:45,885
Looks a little better cuz it defaults to my own methods.
不写好看一点，因为默认就是它自身的方法

911
00:41:45,886 --> 00:41:47,737
I can just do that.
我可以把 self 去掉

912
00:41:49,173 --> 00:41:51,040
So we got the tap recognizer created.
这样 tapRecognizer 就创建好了

913
00:41:51,109 --> 00:41:53,610
Now we have to configure the tap recognizer
我们还要设置一下它

914
00:41:53,678 --> 00:41:56,011
because we want it to happen on single taps.
因为我们希望这是个单击

915
00:41:56,080 --> 00:41:59,148
So we could say for example numberOfTapsRequired = 1,
所以我们可以写 tapRecognizer.numberOfTapsRequired = 1

916
00:41:59,216 --> 00:42:01,618
that happens to be the default, so probably I won't
但是默认就是如此，所以实际上没必要写

917
00:42:01,686 --> 00:42:03,786
need to actually say that, but we'll do it anyway.
不过我们还是写上

918
00:42:03,855 --> 00:42:06,655
And now we need to turn it on and we do that by adding
然后我们需要通过 addGestureRecognizer(_:) 方法

919
00:42:06,724 --> 00:42:08,625
a gestureRecognizer to the FaceView.
把它加到 faceView 上才能使它生效

920
00:42:09,961 --> 00:42:12,662
If you don't do this step of adding it to some view
如果把它加到视图上这步你忘做了的话

921
00:42:12,731 --> 00:42:15,498
then that view is not going to be recognizing this.
那么视图就没法识别这个手势

922
00:42:15,567 --> 00:42:17,500
So it's not gonna be doing anything.
它不会做任何事情

923
00:42:17,569 --> 00:42:19,836
Just an easy step to kind of forget.
这是很容易忘记的一步

924
00:42:20,938 --> 00:42:26,008
All right, so let's
接下来，让我们看看

925
00:42:26,077 --> 00:42:30,612
see if that works.
它能不能正常工作

926
00:42:30,681 --> 00:42:34,683
All right, so tap, it's working.
点几下，一切正常

927
00:42:34,752 --> 00:42:38,554
Every time I tap, it opens and closes the eyes.
每次我点击，通过改变模型中的数据

928
00:42:38,622 --> 00:42:39,856
And it's changing it in the model.
使得眼睛睁开或者闭上

929
00:42:41,292 --> 00:42:42,158
So it changes the model,
它通过改变模型

930
00:42:42,226 --> 00:42:45,761
that causes the update UI to happen, this update UI does
使得 updateUI() 被调用

931
00:42:45,830 --> 00:42:48,464
does this little thing to update the eyes.
updateUI() 会更新眼睛的状态

932
00:42:48,532 --> 00:42:53,536
When it calls eyes open over here okay, eyesOpen.
当它调用 eyesOpen 属性的时候

933
00:42:53,605 --> 00:42:55,504
When it gets set, it calls setNeedsDisplay,
当这个属性被设置时，会调用 setNeedsDisplay()

934
00:42:55,573 --> 00:42:57,106
which causes the thing to redraw.
进而会使系统进行重绘

935
00:42:57,174 --> 00:42:59,909
Everyone got that chain of events?
所有人都弄清这个事件链了吗？

936
00:43:01,780 --> 00:43:04,146
Let's do one other one here.
让我们再做另外一个

937
00:43:04,215 --> 00:43:06,081
Which is to do a swipe.
做一个轻扫

938
00:43:06,150 --> 00:43:08,951
So I'm gonna have a swipe, where swiping up makes
我会添加一个轻扫

939
00:43:09,019 --> 00:43:12,388
our face happier and swiping down makes it sadder.
向上会让脸变得更高兴，向下则是更悲伤

940
00:43:12,456 --> 00:43:14,890
So this has to be handled in the controller.
这也要放在控制器内处理

941
00:43:14,959 --> 00:43:15,524
Why?
为什么？

942
00:43:15,593 --> 00:43:17,092
Because this is affecting the model.
因为这个也影响了模型

943
00:43:17,161 --> 00:43:18,761
Happiness is in the model.
高兴的程度存储在模型中

944
00:43:18,829 --> 00:43:21,831
So I'm gonna have a func called increaseHappiness.
我会加一个方法叫做 increaseHappiness

945
00:43:23,535 --> 00:43:26,135
It's just going to set the expression equal to
它会把 expression 设置为 

946
00:43:26,204 --> 00:43:28,071
the existing expression but happier.
expression.happier

947
00:43:30,608 --> 00:43:32,942
I'll do a func decreaseHappiness,
我还会加一个方法 decreaseHappiness

948
00:43:33,011 --> 00:43:35,077
i's gonna be the opposite,
它正好相反

949
00:43:35,146 --> 00:43:38,213
expression = the current expression but sadder.
expression = expression.sadder

950
00:43:38,282 --> 00:43:40,349
And these vars here, happier and
这两个变量 happier 和 sadder

951
00:43:40,418 --> 00:43:44,454
sadder, those are in the FacialExpression, right here.
它们是 FacialExpression 的属性，在这里

952
00:43:44,522 --> 00:43:46,355
You can look at those later to see how they work.
之后你们可以看看它们是如何工作的

953
00:43:46,424 --> 00:43:47,523
But basically the're just creating a new
基本上它们只是创建了一个新的 FacialExpression

954
00:43:47,592 --> 00:43:50,058
FacialExpression where the mouth is happier or
让嘴型变化，显得更高兴

955
00:43:50,127 --> 00:43:51,461
the mouth is sadder.
或者更悲伤

956
00:43:51,529 --> 00:43:53,428
And then the mouth knows how to be happy or sad or
Mouth 通过枚举中原始值的机制

957
00:43:53,497 --> 00:43:56,132
it's using this raw value mechanism in enum, hopefully
能够知道如何变得更高兴或者更悲伤

958
00:43:56,200 --> 00:43:58,567
you've figured that out in your reading assignment.
希望你们在之前的阅读作业中已经理解了这点

959
00:43:58,636 --> 00:44:01,503
This is a great opportunity to go figure it out if you
如果没有，现在是个很好的机会

960
00:44:01,572 --> 00:44:03,206
didn't.
来理解它

961
00:44:03,274 --> 00:44:08,744
Back in our controller here, we now have these handlers.
回到我们的控制器中，我们已经有了这些处理方法

962
00:44:08,813 --> 00:44:11,414
Notice these handlers have no argument.
注意到它们都没有参数

963
00:44:11,482 --> 00:44:13,182
Why do these handlers not have an argument,
为什么这些处理方法没有参数呢

964
00:44:13,251 --> 00:44:15,551
like this ByReactingTo guy down here.
像下面这个 byReactingTo 

965
00:44:15,620 --> 00:44:17,786
Because a swipe gesture is discrete, so
因为轻扫是非连续的

966
00:44:17,855 --> 00:44:20,456
we never have to look at the swipe gesture when it happens,
我们没必要查看它的状态

967
00:44:20,525 --> 00:44:22,258
we know it happened and that's all we need to know.
我们只需要知道它是不是发生了

968
00:44:22,327 --> 00:44:25,160
So these handlers do not ever need to look at the state or
所以在这些处理方法中，我们没必要查看手势的状态

969
00:44:25,229 --> 00:44:28,297
anything like that, like a tap gesture or a swipe gesture or
或者其他属性，我们不需要传入一个代表点击、轻扫

970
00:44:28,365 --> 00:44:30,032
a pan gesture.
或拖动手势的参数

971
00:44:30,101 --> 00:44:34,403
Let's add these guys to there, so
让我们在这里加些代码

972
00:44:34,471 --> 00:44:39,074
I'm gonna let swipeUpRecognizer =
我会写 let swipeUpRecognizer = UISwipeGestureRecognizer(target:action:)

973
00:44:39,143 --> 00:44:46,849
UISwipeGestureRecognizer, again, target and action.
我们要设置 target 和 action

974
00:44:46,918 --> 00:44:49,318
Again, the target is myself because it affects the model.
然后，target 设置为 self，因为影响了模型

975
00:44:49,386 --> 00:44:53,522
And I'm gonna have this be the selector increaseHappiness
我要把 increaseHappiness 作为 selector 

976
00:44:53,591 --> 00:44:55,958
because this is swipe up.
因为这个是向上扫

977
00:44:56,027 --> 00:44:57,827
Okay, now I have to configure it.
好了，接下来要设置它的参数

978
00:44:57,896 --> 00:45:01,764
SwipeUpRecognizer's direction is up, and
swipeUpRecognizer.direction = .up

979
00:45:01,832 --> 00:45:03,733
now I'm gonna add it,
然后我要把它加到视图上

980
00:45:03,801 --> 00:45:09,272
faceView.addGestureRecognizer- (swipeUpRecognizer).
faceView.addGestureRecognizer(swipeUpRecognizer)

981
00:45:09,340 --> 00:45:10,772
And since swipeDown is so similar,
然后 swipeDown 也是类似的

982
00:45:10,841 --> 00:45:13,176
I'm just going to copy and paste here.
我只要复制粘贴一下

983
00:45:13,244 --> 00:45:15,011
Copy and paste.
复制，粘贴

984
00:45:15,079 --> 00:45:19,415
And we will change swipe up to be swipe down.
然后我们要把 swipeUp 改为 swipeDown

985
00:45:22,720 --> 00:45:24,854
And of course, the direction here now is down.
当然 direction 也要改为 .down

986
00:45:24,922 --> 00:45:29,192
And it's decreaseHappiness and so I decrease.
它的 selector 改为 decreaseHappiness

987
00:45:29,260 --> 00:45:31,994
So I've added these two recognizers, up and
这样我就加完了两个识别器

988
00:45:32,063 --> 00:45:32,929
down swiping.
向上轻扫和向下轻扫

989
00:45:32,997 --> 00:45:34,697
And they're going to increase and
它们要做是增加或降低

990
00:45:34,766 --> 00:45:37,065
decrease our happiness in the model.
模型中的高兴程度

991
00:45:37,134 --> 00:45:40,136
And when the model changes, update UI is called.
当模型改变时，updateUI() 会被调用

992
00:45:40,204 --> 00:45:42,505
We're gonna look up mouth curvature in that dictionary.
我们会查看那个字典中的嘴部曲线

993
00:45:42,573 --> 00:45:44,206
We're gonna set the mouth curvature,
我们会设置嘴部曲线

994
00:45:44,275 --> 00:45:46,475
that's gonna do the didSet, we're in good shape.
进而这会导致 didSet 被调用

995
00:45:46,544 --> 00:45:49,778
So here we have a pretty sad guy, we'll open his eyes,
当前这个人看起来相当不高兴，我们让它睁开眼睛

996
00:45:49,847 --> 00:45:51,914
then we'll close, no leave them open.
然后闭上眼睛

997
00:45:51,983 --> 00:45:53,015
Now we're gonna make him happier, and
我们让他变得高兴点

998
00:45:53,083 --> 00:45:54,049
happier, and happier.
再高兴点，更高兴点

999
00:45:54,118 --> 00:45:55,551
Woo, he's really happy!
喔，他看起来相当高兴

1000
00:45:55,620 --> 00:45:59,055
And swiping down, no, not so happy after all.
然后向下轻扫，没那么高兴了

1001
00:46:02,193 --> 00:46:03,659
So that's it for gestures.
这就是手势部分

1002
00:46:03,728 --> 00:46:07,129
Gestures are super-simple and super-powerful cuz all
手势非常简单，同时非常强大

1003
00:46:07,198 --> 00:46:10,532
the logic going into detecting was that a swipe, or was that
因为所有检测是轻扫、点击、拖动还是其他手势的逻辑

1004
00:46:10,601 --> 00:46:12,969
a pan, or what was that, was all done for you by iOS.
iOS 都帮你做好了

1005
00:46:16,074 --> 00:46:21,243
Back to our
回到我们的

1006
00:46:21,312 --> 00:46:26,716
slides.
幻灯片中

1007
00:46:26,785 --> 00:46:29,618
Time to talk about building bigger apps,
是时候谈谈怎么创建更大型的应用了

1008
00:46:29,687 --> 00:46:33,622
apps where we're gonna have multiple MVCs involved.
将会牵扯到多个 MVC 的应用

1009
00:46:33,691 --> 00:46:36,391
Not just our calculator MVC, but multiple MVCs.
不仅仅只有一个计算器的 MVC，而是多个 MVC

1010
00:46:36,460 --> 00:46:39,528
Not just our face view controller MVC, but
 不仅仅只有一个 FaceViewController 的 MVC

1011
00:46:39,597 --> 00:46:41,230
multiple MVCs.
而是更多 MVC

1012
00:46:41,298 --> 00:46:45,735
So I showed you this picture from the MVC discussion and
所以我给你们展示这张关于 MVC 讨论的图

1013
00:46:45,803 --> 00:46:48,937
you can see that the MVCs relationship to each other is
你们可以看到 MVC 之间的关系

1014
00:46:49,006 --> 00:46:54,209
that one or more MVCs is part of the view of another MVC.
一个或多个 MVC 可能是另外一个 MVC 的视图中的一部分

1015
00:46:54,278 --> 00:46:57,713
So let's see how that happens.
让我们看看这是如何产生的

1016
00:46:57,781 --> 00:47:03,085
We combine these MVCs using, (I don't wanna say special,
虽然我不想指定某个特例

1017
00:47:03,154 --> 00:47:06,188
because you could write your own), but
因为你们可以实现自己的 MVC

1018
00:47:06,257 --> 00:47:09,391
built-in MVCs that come with iOS.
但是这里我们使用 iOS 内建的 MVC 来组合其他 MVC

1019
00:47:09,460 --> 00:47:12,027
And these MVCs are built
这些 MVC 使用其他 MVC

1020
00:47:12,096 --> 00:47:14,796
using other MVCs as part of their view.
来构成自己视图的一部分

1021
00:47:14,865 --> 00:47:17,533
So, yes you can build your own.
这种 MVC 你也可以自己创建

1022
00:47:17,601 --> 00:47:20,535
So, for example, here's the three that we do most of our
举例来说，这三个是我们最常用来构建应用的

1023
00:47:20,604 --> 00:47:22,704
building with here or pretty much all of our building,
或者说相当多的多 MVC 应用

1024
00:47:22,773 --> 00:47:23,706
multiple MVCs.
都是用它们构建的

1025
00:47:23,774 --> 00:47:26,708
There's the TabBarController, a SplitViewController and
它们是 UITabBarController，UISplitViewController

1026
00:47:26,777 --> 00:47:27,977
a NavigationController.
和 UINavigationController

1027
00:47:28,045 --> 00:47:30,879
So I'm gonna go into detail here about how each of these
我会深入细节解释下

1028
00:47:30,948 --> 00:47:34,282
controllers, are controllers of MVCs
为什么这些控制器被称为控制 MVC 的控制器

1029
00:47:34,351 --> 00:47:36,886
whose view is other MVCs.
它们的视图是其他 MVC

1030
00:47:38,189 --> 00:47:41,089
So here's a TabBarController for example.
以标签栏控制器为例

1031
00:47:41,158 --> 00:47:43,158
If you look at what you see up there,
你们看屏幕上

1032
00:47:43,227 --> 00:47:47,195
there are two MVCs on that screen, two.
有两个 MVC

1033
00:47:47,264 --> 00:47:49,732
One MVC is the TabBarController.
其一是标签栏控制器

1034
00:47:49,800 --> 00:47:52,334
It's what's drawing the little icons at the bottom.
它负责绘制底部的小图标

1035
00:47:52,403 --> 00:47:55,103
You see those icons at the bottom, those four icons?
你们看到那四个小图标了吗

1036
00:47:55,172 --> 00:47:56,972
That MVC is doing that.
它做的就是这些

1037
00:47:57,041 --> 00:47:59,642
The other MVC is the thing surrounded in yellow,
另一个 MVC 也就是黄色边框的那个

1038
00:47:59,710 --> 00:48:02,011
a dashboard MVC, whatever that is,
一个 Dashboard MVC，它是什么无关紧要

1039
00:48:02,080 --> 00:48:04,213
something in the health app here or something.
它可能是健康应用或者其他某个应用的内容

1040
00:48:04,281 --> 00:48:07,249
That is drawn by a completely different MVC,
它是由另外一个非常复杂的 MVC 绘制的

1041
00:48:07,318 --> 00:48:08,684
the dashboard MVC.
也就是这个 Dashboard MVC

1042
00:48:08,752 --> 00:48:12,087
But notice how it's drawing inside the view
但是注意它是如何把自己的内容绘制在

1043
00:48:12,156 --> 00:48:13,889
of the tab bar controller.
标签栏控制器的内部的

1044
00:48:13,958 --> 00:48:17,526
So, you're already seeing here how we're building an MVC out
其实你们现在看到的正是如何把许多 MVC

1045
00:48:17,595 --> 00:48:19,461
of other MVCs.
嵌入到一个 MVC 中的例子

1046
00:48:19,530 --> 00:48:23,498
The tab bar controller has an MVC built into its view.
这个标签栏控制器把另一个 MVC 嵌入到自己的视图中

1047
00:48:23,567 --> 00:48:26,568
Now, what's interesting is this is very object oriented
非常有趣的一点是底部的那些按钮具有非常面向对象的一面

1048
00:48:26,637 --> 00:48:29,872
in that those buttons along the bottom, both the icon and
不仅是它们的图标和文字

1049
00:48:29,941 --> 00:48:31,807
the text on and if they had a badge,
它们还可能拥有一个角标

1050
00:48:31,876 --> 00:48:32,875
that would be there too.
也会出现在那里

1051
00:48:32,943 --> 00:48:37,179
Those are actually not being set in the TabBarController,
实际上全部这些都不是在标签栏控制器中设置的

1052
00:48:37,248 --> 00:48:40,082
the TabBarController is grabbing them from
标签栏控制器只是从

1053
00:48:40,151 --> 00:48:41,050
the dashboard MVC.
Dashboard MVC 那里抓过来

1054
00:48:43,754 --> 00:48:45,988
Grabs them from a var in the dashboard MVC,
通过 Dashboard MVC 的一个变量抓取过来

1055
00:48:46,057 --> 00:48:49,724
it's a UIViewController var called TabBarItem.
它是 UIViewController 的变量，叫做 tabBarItem

1056
00:48:49,793 --> 00:48:54,263
And TabBarItem has things like Badges, and titles, and icons,
并且 tabBarItem 还拥有角标、标题、图标

1057
00:48:54,332 --> 00:48:56,465
things like that.
和其他一些东西

1058
00:48:56,533 --> 00:49:00,001
And of course, we can have more MVCs in the tab bar if I
当然，当我们点击标签栏第二个标签时

1059
00:49:00,070 --> 00:49:02,271
click on that second icon right there,
会出现更多的 MVC

1060
00:49:02,339 --> 00:49:05,340
I get a different MVC filling up this space at the top.
我得到了一个新的 MVC，它填充了屏幕的上部区域

1061
00:49:05,409 --> 00:49:07,843
So now, we've seen three MVCs so
所以，目前我们已经看到了三个 MVC

1062
00:49:07,912 --> 00:49:11,646
far, dashboard, health data, and the TabBarController.
分别是 Dashboard，Health Data 和标签栏控制器

1063
00:49:11,715 --> 00:49:15,984
Right, now by the way, if you get too many tabs, if you put
顺带提一句，如果你有非常多的标签

1064
00:49:16,053 --> 00:49:19,187
six MVCs, for example, into a tab bar controller,
比如一个标签栏控制器中放入六个标签

1065
00:49:19,256 --> 00:49:22,924
then you get a little more "..." icon on the right, and
你会得到一个出现在最右边的代表“更多”的标签

1066
00:49:22,993 --> 00:49:24,593
you can click that and the user can get at those.
用户可以点击它，然后就能看到其余标签

1067
00:49:24,661 --> 00:49:29,164
So a tab bar controller could have more than five MVCs.
所以一个标签栏控制器可以拥有超过五个 MVC

1068
00:49:29,233 --> 00:49:30,966
But if you start getting more than five,
但是一旦真的超过五个

1069
00:49:31,034 --> 00:49:33,502
the UI gets a little clunky because their user is having
界面就会变得有点臃肿

1070
00:49:33,570 --> 00:49:35,571
to go over and click that more to get to the other one.
用户不得不点击“更多”才能访问其余的标签

1071
00:49:35,640 --> 00:49:37,640
I kinda recommend if you have a tab bar,
我建议如果你用了标签栏控制器

1072
00:49:37,709 --> 00:49:39,808
don't put more than five MVCs in there.
尽量不要放超过五个标签

1073
00:49:39,876 --> 00:49:43,812
So the question is, when we have the icons at the bottom
一个问题，当我们有了底部图标

1074
00:49:43,881 --> 00:49:46,381
and like, the icons and the titles there.
图标和它的标题

1075
00:49:46,450 --> 00:49:48,651
And I said that it's getting that from the MVCs that
我刚刚说过它们的来源是

1076
00:49:48,719 --> 00:49:49,951
are being shown.
当前标签页的 MVC

1077
00:49:50,020 --> 00:49:56,058
The question is, is the embedded
问题是当前嵌入的 MVC

1078
00:49:56,127 --> 00:49:59,027
MVC, like the health data one, or the dashboard one, is it
比如 Heath Data 或者 Dashboard

1079
00:49:59,096 --> 00:50:03,032
getting the button and the title there from the model?
它们是从模型中获取按钮的图标和标题的吗？

1080
00:50:03,101 --> 00:50:05,433
And the answer is, that's up to that MVC.
答案是一切取决于那个 MVC

1081
00:50:05,502 --> 00:50:09,304
Some MVCs might well do that, probably most are not because
一些 MVC 可能会这样做，但是绝大多数可能不会

1082
00:50:09,373 --> 00:50:12,808
it's kinda more of a UI thing what the icon and the text is.
图标和它的标题更像是一个界面元素的内容

1083
00:50:12,877 --> 00:50:15,744
Probably not part of the model, especially the icon.
可能不在模型中，尤其是图标

1084
00:50:15,813 --> 00:50:23,151
Unlikely to be in the model.
不太像是来自于模型的

1085
00:50:23,220 --> 00:50:28,356
We have more MVCs for a total of five MVCs on the screen.
现在屏幕上展示的是一个拥有五个 MVC 的多 MVC 应用

1086
00:50:28,425 --> 00:50:29,691
The tab bar controller and
一个标签栏控制器

1087
00:50:29,760 --> 00:50:32,828
these four MVCs that are each of the tabs.
四个标签页面 MVC

1088
00:50:32,896 --> 00:50:37,532
So this is the simplest way to combine MVCs.
这就是最简单的组合 MVC 的方式

1089
00:50:37,601 --> 00:50:40,335
But do you see what I mean when I say that these other
但是你们理解我说的

1090
00:50:40,404 --> 00:50:44,139
MVCs are part of the view of the tab bar controller.
“其他 MVC 是构成标签栏控制器的视图的一部分”这句话的意思吗

1091
00:50:44,208 --> 00:50:47,743
They're actually even their views are embedded physically
它们实际上把自己的视图在物理层面上嵌入到了

1092
00:50:47,812 --> 00:50:52,915
embedded inside the tab bar controller's view.
标签栏控制器的视图的内部

1093
00:50:52,984 --> 00:50:54,716
So that's the simplest one.
以上就是最简单的一个例子

1094
00:50:54,785 --> 00:50:56,552
Let's talk about the next simplest one,
让我们来讲下一个简单的方法

1095
00:50:56,621 --> 00:50:58,153
which is split view controller.
也就是分屏控制器（UISplitViewController）

1096
00:50:58,222 --> 00:51:03,025
So split view controllers is two MVCs side by side.
分屏控制器是两个并排的 MVC 

1097
00:51:03,094 --> 00:51:05,694
You get to see them both on screen at the same time,
也就是能在屏幕上同时看到的两个 MVC 

1098
00:51:05,763 --> 00:51:07,262
at least in landscape you do.
至少能在横屏模式下同时看到

1099
00:51:07,331 --> 00:51:10,866
This one on the left here is a calculator MVC.
这里左边的这个是一个计算器的 MVC 

1100
00:51:10,935 --> 00:51:12,735
It doesn't look much like yours but
它跟你们的计算器不大像但是

1101
00:51:12,804 --> 00:51:15,037
you can imagine that's a calculator MVC.
你可以把它当作一个计算器的 MVC 

1102
00:51:15,105 --> 00:51:15,837
That MVC,
这个 MVC

1103
00:51:15,906 --> 00:51:20,409
we call the master MVC of the split view controller.
在分屏控制器中我们把它叫做主 MVC 

1104
00:51:20,477 --> 00:51:23,044
And then on the other side there's a whole different MVC,
然后另一边有一个完全不一样的 MVC 

1105
00:51:23,113 --> 00:51:24,713
completely and utterly different.
完完全全不同

1106
00:51:24,782 --> 00:51:29,251
This one happens to be a graph of
这个刚好就是

1107
00:51:29,320 --> 00:51:31,486
what's in the calculator MVC.
计算器 MVC 里内容对应的图形

1108
00:51:31,555 --> 00:51:32,888
And this is gonna look very similar
这个跟你们的作业看起来非常像

1109
00:51:32,957 --> 00:51:35,724
to your homework assignment, because that is assignment 3.
因为这就是作业三

1110
00:51:35,793 --> 00:51:37,493
To build a graphing calculator,
作业三就是去做一个图形计算器

1111
00:51:37,561 --> 00:51:38,894
you're gonna be putting in a split view and
你将会用到分屏控制器

1112
00:51:38,962 --> 00:51:40,662
doing all the things I'm talking about today,
然后做今天我将要说的内容

1113
00:51:40,731 --> 00:51:42,030
so pay attention.
所以专注点

1114
00:51:42,099 --> 00:51:43,098
So that we call a detail.
右边那一个 MVC 我们叫它细节 MVC 

1115
00:51:43,167 --> 00:51:44,699
The reason we call that a detail,
我们之所以叫它细节 MVC 

1116
00:51:44,768 --> 00:51:46,568
is almost always the right side,
是因为它几乎都在右边

1117
00:51:46,637 --> 00:51:51,740
which is larger usually, whatever's in it happens
也就是通常更大的那一块，无论它里面有什么

1118
00:51:51,809 --> 00:51:54,143
to be controlled by what's on the left by the master.
它都是被左边的主 MVC 控制的

1119
00:51:54,212 --> 00:51:55,677
And that would be true here.
这个例子就很符合

1120
00:51:55,746 --> 00:51:58,313
Cuz the graph on the right is showing whatever is in
因为无论左边的计算器里是什么内容

1121
00:51:58,382 --> 00:51:59,280
the calculator on the left.
右边的图形都会显示它

1122
00:51:59,349 --> 00:52:01,216
So if you change something in the calculator on the left and
所以如果你在左边的计算器里改变了些什么

1123
00:52:01,285 --> 00:52:03,719
hit its graphing button, it changes the details.
然后点击图形按钮，就改变了右边的细节

1124
00:52:03,788 --> 00:52:08,123
So the master is controlling the detail in that way.
这就是主 MVC 控制细节 MVC 的方式

1125
00:52:08,192 --> 00:52:10,693
Now, and this is what it looks like when these things
这是横屏模式下

1126
00:52:10,761 --> 00:52:12,461
are side-by-side in landscape mode.
它们并排摆放的样子

1127
00:52:12,530 --> 00:52:14,630
But what if you switch over to portrait?
但如果切换到竖屏模式呢？

1128
00:52:14,699 --> 00:52:17,632
Well, in portrait it just shows you the detail, but
竖屏模式下它只会显示细节 MVC 

1129
00:52:17,701 --> 00:52:22,204
you can swipe from the left and get the master to come
但是你可以从左向右滑然后

1130
00:52:22,273 --> 00:52:24,773
out on top of it and then do whatever you want.
就能让主 MVC 显示出来，接下来你可以随意操作

1131
00:52:24,842 --> 00:52:26,074
It still updates the utility and
它仍然会更新这个程序并且

1132
00:52:26,143 --> 00:52:27,476
you can swipe it out of the way.
你也可以把它滑回去

1133
00:52:30,047 --> 00:52:31,212
So that's split view controller.
这就是分屏控制器了

1134
00:52:31,281 --> 00:52:32,348
Super simple.
超级简单

1135
00:52:32,416 --> 00:52:35,717
Again, hopefully you're seeing that there are three MVCs
再次提醒，希望你们能明白这里有三个 MVC

1136
00:52:35,735 --> 00:52:35,760
up here.

1137
00:52:35,786 --> 00:52:39,860
The split view controller's MVC, and these master and
分屏控制器的 MVC，和这个主 MVC 还有

1138
00:52:40,057 --> 00:52:41,089
detail MVCs.
细节 MVC

1139
00:52:41,158 --> 00:52:44,459
The master details serve as the view of
所以主 MVC 和 细节 MVC 作为

1140
00:52:44,528 --> 00:52:45,427
that split view controller.
分屏控制器 MVC 的视图

1141
00:52:45,496 --> 00:52:48,764
Notice that the split view controller itself has no UI.
注意分屏控制器本身是没有 UI 界面的

1142
00:52:48,833 --> 00:52:50,432
It doesn't actually draw anything in the view,
它在视图上没有绘制任何东西

1143
00:52:50,501 --> 00:52:55,103
it just uses the UI or the view of these MVCs to draw.
它只是单纯的调用了 UI 界面或者这些 MVC 的视图来绘制

1144
00:52:55,172 --> 00:52:57,873
I guess, it draws the vertical line between the two,
我猜，它大概绘制了那两个 MVC 中间垂直的那条线

1145
00:52:57,942 --> 00:53:01,743
that's probably drawn by the split view.
这大概就是分屏控制器绘制的

1146
00:53:01,812 --> 00:53:03,479
The most complicated one and
最复杂并且

1147
00:53:03,547 --> 00:53:07,616
the most commonly used one, is a navigation controller.
最常用的一个是导航控制器（UINavigationController）

1148
00:53:07,685 --> 00:53:12,354
Another MVC that uses other MVCs in its view.
另一个把别的 MVC 作为它视图的 MVC

1149
00:53:12,423 --> 00:53:16,358
So, here we see two MVCs on this screen,
这个屏幕上有两个 MVC 

1150
00:53:16,427 --> 00:53:19,027
navigation controller based MVC.
基于导航控制器的 MVC 

1151
00:53:19,096 --> 00:53:22,231
And in it, it's showing another MVC,
和它里面显示的另一个 MVC 

1152
00:53:22,300 --> 00:53:24,700
which I'm calling the all settings MVC.
这个 MVC 我会叫它所有设置 MVC

1153
00:53:26,470 --> 00:53:29,004
In this particular view that you're looking at.
这个你正看着的特殊的视图里

1154
00:53:29,073 --> 00:53:31,139
See on the top there's a gray bar that says
看到顶部有一个叫做 Settings 的

1155
00:53:31,208 --> 00:53:32,841
settings in there?
灰色的栏了吗？

1156
00:53:32,910 --> 00:53:35,844
The gray bar, which is actually transparent and
这个灰色栏，事实上是透明的

1157
00:53:35,913 --> 00:53:38,214
showing the all settings MVC behind it.
并且它显示了在它后面的所有设置 MVC 

1158
00:53:39,216 --> 00:53:41,450
Kinda, fuzzed out a little bit.
稍微有一点点模糊

1159
00:53:41,519 --> 00:53:45,253
That gray bar is drawn by the navigation controller.
这个灰色栏是导航控制器绘制的

1160
00:53:45,322 --> 00:53:46,522
That and a toolbar on the bottom,
还有下面的工具栏

1161
00:53:46,590 --> 00:53:48,657
which I'll talk about in a second, that's the only thing
也就是我马上会讲的东西，这些是

1162
00:53:48,726 --> 00:53:51,193
that the navigation controller actually draws in its view.
导航控制器唯一绘制在它视图上的东西

1163
00:53:51,262 --> 00:53:55,029
The rest of its view, it fills up with another MVC.
其余的视图都是被另一个 MVC 填充的

1164
00:53:55,098 --> 00:53:56,598
The view from another MVC,
也就是另一个 MVC 中的视图

1165
00:53:56,666 --> 00:53:58,734
in this case the all settings MVC.
在这个情况下，也就是这个所有设置 MVC 

1166
00:54:02,906 --> 00:54:05,107
The contents are all this "all settings MVC".
里面的内容都是这个所有设置 MVC

1167
00:54:06,544 --> 00:54:08,577
Just like with the tab bar controller where there was
就像标签栏控制器

1168
00:54:08,645 --> 00:54:11,213
that tab bar item that had like the icon and
在标签栏上有图标和

1169
00:54:11,281 --> 00:54:11,846
the title on it.
标题

1170
00:54:11,915 --> 00:54:13,949
Same thing with the navigation controller.
导航控制器也是一样的

1171
00:54:14,018 --> 00:54:16,484
That word settings at the top,
这个最顶部的 Settings 单词

1172
00:54:16,553 --> 00:54:20,522
the navigation controller MVC is getting that word by asking
导航控制器 MVC 是通过询问

1173
00:54:20,591 --> 00:54:23,626
the MVC that it's currently showing what's your title.
当前显示的 MVC 来确定标题的

1174
00:54:25,696 --> 00:54:29,898
It gets that from this var navigation item.
它通过 navigationItem 这个变量来获取它

1175
00:54:29,967 --> 00:54:31,065
It's a UI view controller thing,
这是一个 UIViewController 的东西

1176
00:54:31,134 --> 00:54:34,002
just like tab bar item has all the tab bar things, navigation
就像标签栏控制器有所有标签栏相关的东西

1177
00:54:34,071 --> 00:54:37,306
has all the navigation, UI navigation things.
导航控制器有所有的 UINavigation 相关的东西

1178
00:54:37,375 --> 00:54:39,474
So if you look at the API for navigation item,
如果你查阅 navigationItem 相关的 API 的话

1179
00:54:39,543 --> 00:54:42,110
it has things in there like title, and I'm gonna show
它里面有些例如标题的东西，接下来我要

1180
00:54:42,179 --> 00:54:44,812
you another property that it's gonna use in a second to get
展示给你们另一个马上要用到的属性来

1181
00:54:44,881 --> 00:54:46,282
more information to draw.
得到更多用于绘制的信息

1182
00:54:48,018 --> 00:54:51,420
If I click in this table view actually,
如果我点击了这个表格视图

1183
00:54:51,489 --> 00:54:55,157
if I click on general right there, then a new MVC is
如果我点击了这里的 General，然后一个全新的 MVC 将

1184
00:54:55,226 --> 00:54:59,427
gonna slide in on top of that old settings one.
滑动到旧的设置的上面

1185
00:54:59,496 --> 00:55:02,597
Now, the old settings one is completely non-visible but
现在，原先的设置已经看不到了，但是

1186
00:55:02,666 --> 00:55:03,399
it's still there.
它还在那

1187
00:55:04,435 --> 00:55:05,767
This is like a stack of cards,
就像是一叠卡片

1188
00:55:05,836 --> 00:55:07,736
like I've put a new card on top.
比如我把一张卡片放到顶部

1189
00:55:07,804 --> 00:55:11,005
The other card is no longer on screen, okay,
那么别的卡片就不会出现在屏幕上了，知道吗

1190
00:55:11,074 --> 00:55:12,374
you won't see it any more.
你不会再看到它了

1191
00:55:13,910 --> 00:55:16,811
But it still exists in memory, in the navigation controller.
但在内存里它仍然还在那里，仍然在导航控制器里

1192
00:55:16,880 --> 00:55:20,081
So now we have three MVCs involved in this
那么现在我在导航控制器里

1193
00:55:20,150 --> 00:55:23,185
Navigation Controller, the Navigation Controllers' MVC,
有三个涉及到的 MVC，一个是导航控制器 MVC 

1194
00:55:23,253 --> 00:55:26,788
the all setting ones that is now in the back of this one,
一个是在这个正在显示的 MVC 的后面的所有设置 MVC 

1195
00:55:26,857 --> 00:55:31,059
and this one, the General Settings MVC.
最后是这个，通用设置 MVC 

1196
00:55:31,128 --> 00:55:32,494
Now, by the way, there,
顺带一提

1197
00:55:32,562 --> 00:55:35,463
you can have toolbar buttons along the bottom here.
你可以在底部加上工具栏按钮

1198
00:55:35,532 --> 00:55:37,098
They look similar to the tab bar ones,
它看起来跟标签栏差不多

1199
00:55:37,167 --> 00:55:38,934
but they're a little different.
但它们有一点不同

1200
00:55:39,002 --> 00:55:42,470
That is set with the toolbar item, the var in
这是用 toolbarItems 设置的，也就是

1201
00:55:42,539 --> 00:55:45,941
the General Settings MVC, not in the Navigation Controller.
一个通用设置 MVC 里的变量，不是导航控制器里的

1202
00:55:46,010 --> 00:55:48,944
So as new MVCs slide in, the toolbar buttons at
那么当新的 MVC 滑入的时候，底部的

1203
00:55:49,013 --> 00:55:51,713
the bottom would change, because they're connected to
工具栏按钮就会改变，因为它们是与

1204
00:55:51,782 --> 00:55:54,916
whatever happens to be on top of the deck of cards.
顶层的卡片相连接的

1205
00:55:54,985 --> 00:55:58,519
Notice also that there's a back button.
注意那里有一个返回按钮

1206
00:55:58,588 --> 00:55:59,454
You see that back button?
你们看到那个返回按钮了吗？

1207
00:55:59,522 --> 00:56:01,055
It's called settings.
它叫做 Settings

1208
00:56:01,124 --> 00:56:03,658
That button was automatically put there by navigation
这个按钮是导航控制器自动

1209
00:56:03,727 --> 00:56:04,826
controller.
放在那里的

1210
00:56:04,894 --> 00:56:05,927
And if you click that,
并且如果你点击它的话

1211
00:56:05,996 --> 00:56:07,563
it's gonna go back to the other card.
它就会返回到之前的卡片

1212
00:56:07,631 --> 00:56:10,666
The all settings, so that's all done for you.
也就是所有设置，这就是它为你们做的事

1213
00:56:12,336 --> 00:56:14,002
But if I click somewhere in here,
但如果我点击了这里的某个地方的话

1214
00:56:14,070 --> 00:56:18,106
like on Accessibility there, then it goes to another MVC.
例如那里的辅助功能，接下来它就到另一个 MVC 去

1215
00:56:18,175 --> 00:56:21,376
Now we've seen four MVCs so far in this thing.
现在我们已经看了四个 MVC 了

1216
00:56:21,445 --> 00:56:24,179
And if I click on Larger Text in here, I get yet
然后如果我点击了这里的更大字体

1217
00:56:24,248 --> 00:56:25,013
another MVC..
我又得到了另一个 MVC 

1218
00:56:25,081 --> 00:56:27,015
Now we have five MVCs.
现在我们就有五个 MVC 了

1219
00:56:27,083 --> 00:56:29,418
So these MVCs just keep stacking on top, and
这些 MVC 只是单纯地一个个叠到顶部

1220
00:56:29,486 --> 00:56:32,320
each of the new one that comes on is its own world.
然后每一个都会带来它自己的世界

1221
00:56:32,389 --> 00:56:34,422
It's completely on its own.
完全取决于它自己

1222
00:56:34,491 --> 00:56:37,592
And of course if we start pressing the back button
当然了如果我们点击这个左上方的返回按钮的话

1223
00:56:37,661 --> 00:56:40,862
up there on the left, it goes back to the previous one.
它就返回到了先前的一个 MVC 

1224
00:56:40,931 --> 00:56:43,698
Notice the title of the back button is even set
注意这个返回按钮的标题甚至都

1225
00:56:43,767 --> 00:56:45,934
to be the title of the previous MVC so
已经被设置成先前一个 MVC 的标题

1226
00:56:46,003 --> 00:56:49,103
you know what can happen when you click it.
所以你就能知道当你点了后会发生些什么

1227
00:56:49,172 --> 00:56:51,506
And we can go all the way back to the all settings at
然后我们可以一直返回到最开头的

1228
00:56:51,575 --> 00:56:52,207
the very top.
所有设置 MVC 

1229
00:56:52,275 --> 00:56:53,675
Now there's no back button because
现在没有返回按钮了

1230
00:56:53,744 --> 00:56:54,576
there's no other cards.
因为已经没有别的卡片了

1231
00:56:56,146 --> 00:56:57,779
So that's what navigation controller
这就是导航控制器的

1232
00:56:57,847 --> 00:56:59,214
looks and works like.
样子和它工作的方式

1233
00:56:59,282 --> 00:57:02,750
Okay, you guys have all seen this UI, I'm sure, in apps.
你们已经看过这些 UI 界面了，我很确定，就在 app 里

1234
00:57:02,819 --> 00:57:04,652
Super common.
非常常用

1235
00:57:04,721 --> 00:57:07,222
So let's talk a little bit of how the navigation controller
那么我们来谈谈导航控制器

1236
00:57:07,291 --> 00:57:08,490
works behind the scenes.
幕后是如何工作吧

1237
00:57:09,559 --> 00:57:10,959
How how you make this thing work.
如何生效

1238
00:57:11,027 --> 00:57:13,194
So when do you need a navigation controller?
那么你什么时候需要一个导航控制器呢？

1239
00:57:13,263 --> 00:57:16,431
Well, let's see you have an MVC, right there, and
我们假设你有一个 MVC，就在那

1240
00:57:16,499 --> 00:57:19,701
you got another whole pile of UI down here in the corner
并且你在角落里有一堆想要添加的

1241
00:57:19,770 --> 00:57:22,304
that you wanna add, but just won't fit.
内容，但是放不下

1242
00:57:22,373 --> 00:57:24,305
You wanna be able to do the accessibility stuff and
你想要实现在之前的幻灯片中看到的

1243
00:57:24,374 --> 00:57:27,175
the larger texts and all that we saw on the previous slide.
辅助功能、更大字体和其他一些东西

1244
00:57:27,244 --> 00:57:27,976
But it obviously,
但很明显

1245
00:57:28,044 --> 00:57:29,744
it's not gonna all fit in one phone screen so
手机屏幕装不下这么多东西

1246
00:57:29,813 --> 00:57:30,945
you need more space.
所以你需要更多空间

1247
00:57:31,014 --> 00:57:35,116
So what you do is you create a new MVC that controls all that
那么你要做的就是创建一个新的

1248
00:57:35,185 --> 00:57:39,120
UI that is completely independent of that.
独立的 MVC 来控制那些 UI

1249
00:57:39,189 --> 00:57:40,722
And it just knows how to manage that.
那个独立的 MVC 知道如何管理它们

1250
00:57:40,791 --> 00:57:42,624
Now they might share a model, because maybe they're
它们可能共享同一个模型，因为它们都在

1251
00:57:42,693 --> 00:57:44,292
all looking in the settings database.
查看设置数据库

1252
00:57:44,361 --> 00:57:45,127
That's fine.
那没事

1253
00:57:45,195 --> 00:57:48,163
But they're not talking to each other in any way.
但它们任何情况下都不会互相沟通

1254
00:57:48,231 --> 00:57:49,397
The only time they ever talk to each other,
唯一它们沟通的时候就是

1255
00:57:49,466 --> 00:57:50,932
is when it first comes on screen,
当第一次出现在屏幕上的时候

1256
00:57:51,001 --> 00:57:52,634
as you'll see in a moment.
就像你马上会看到的一样

1257
00:57:54,271 --> 00:57:55,938
So I have two MVC's now,
那么我现在有两个 MVC 

1258
00:57:56,006 --> 00:57:59,941
to control all the UI that I wanna present.
用来控制所有我想要展示的 UI 界面

1259
00:58:00,010 --> 00:58:01,810
So let's use a NavigationController to make
让我们用一个导航控制器来

1260
00:58:01,878 --> 00:58:03,244
these come on screen.
使他们出现在屏幕上吧

1261
00:58:03,313 --> 00:58:04,913
And so here's a NavigationController,
那么这就是一个导航控制器了

1262
00:58:04,982 --> 00:58:07,281
it's just a MVC.
就是个 MVC 

1263
00:58:07,350 --> 00:58:11,586
It doesn't really have a model that's okay but it has a view.
事实上它没有一个模型，这没事，但它有一个视图

1264
00:58:11,655 --> 00:58:14,989
And inside that view there is a special var that's pointing
而且在这个视图中有一个叫做

1265
00:58:15,058 --> 00:58:17,359
to its view called RootViewController,
rootViewController 的指向它的视图的特殊变量

1266
00:58:17,427 --> 00:58:20,729
that's just points of the controller of the MVC that's
它指向根 MVC 中的控制器

1267
00:58:20,798 --> 00:58:23,098
at the root it's the base card.
也就是卡片中最底下的那张

1268
00:58:23,166 --> 00:58:25,167
The all settings one we saw on the previous page.
也就是之前在幻灯片中出现的所有设置

1269
00:58:26,303 --> 00:58:27,001
So it just has this var.
它有这么一个变量

1270
00:58:27,070 --> 00:58:28,670
You just set that to something, and
你只需要设置一些东西

1271
00:58:28,739 --> 00:58:29,471
now you'll have an MVC.
然后你就有了一个 MVC 

1272
00:58:29,540 --> 00:58:31,839
And as soon as you do that, as soon as you set that,
而且只要你做了这个，只要你设置了

1273
00:58:31,908 --> 00:58:33,909
it's going to take that MVC's view and
它就会把指向的 MVC 中的视图

1274
00:58:33,978 --> 00:58:36,444
put it in its view with that little gray bar.
用那个小小的灰色栏中包装然后放到它自己的视图中

1275
00:58:36,513 --> 00:58:38,780
And it's gonna ask it navigation item for
然后它就会向它的 navigationItem 询问

1276
00:58:38,849 --> 00:58:40,382
the title, and get the title.
它的标题，然后得到标题

1277
00:58:41,918 --> 00:58:42,350
Perfect example.
完美的例子

1278
00:58:42,418 --> 00:58:43,785
This is super simple.
这个非常简单

1279
00:58:43,853 --> 00:58:48,323
And then let's say you have a button inside this UI, or
然后我们假设在新的 UI 界面中有一个按钮，或者

1280
00:58:48,392 --> 00:58:51,259
like a line in the table view, like get me more settings or
像是表格视图中的一条，比如给我更多的设置或者

1281
00:58:51,328 --> 00:58:52,627
accessibility or whatever.
之前幻灯片中的那个辅助功能或者别的什么

1282
00:58:52,696 --> 00:58:53,862
And you touch that.
然后你点击它

1283
00:58:53,931 --> 00:58:57,832
Now, when you touch that, it's going to create one of these
当你点击它的时候，它就将创建右边这些 MVC 中的一个

1284
00:58:57,901 --> 00:59:00,368
MVCs on the right, it creates it at that moment.
它就在那个时候创建

1285
00:59:00,437 --> 00:59:02,804
As soon as you touch it, it creates a new one.
一旦你点击它的时候，它就会创建一个新的 MVC 

1286
00:59:02,873 --> 00:59:05,273
Every single time you go to a new card,
每次你进入一个新的卡片的时候

1287
00:59:05,341 --> 00:59:06,374
it creates a new one.
它就创建一个新的

1288
00:59:06,443 --> 00:59:08,843
Not back, but every time you go forward to a new card,
不是返回，而是重新进入一个新的卡片

1289
00:59:08,912 --> 00:59:10,278
it always creates a new one.
通常都是创建一个新的

1290
00:59:10,347 --> 00:59:11,613
That's something I'm gonna say three or
在这个幻灯片中

1291
00:59:11,682 --> 00:59:12,614
four times in this slide so
我会说三到四次

1292
00:59:12,682 --> 00:59:13,715
as to make sure you understand it.
以确保你们理解它

1293
00:59:15,418 --> 00:59:18,686
This activity of going to a new one is called segueing.
这个进入新的一个 MVC 的活动叫做 segueing

1294
00:59:18,755 --> 00:59:23,891
This particular segue's called a show or a push segue.
这个特殊 segue 被称为 show segue 或者 push segue 

1295
00:59:23,960 --> 00:59:26,561
Which just means a segue in a navigation control with
也就是一个有那叠卡片的

1296
00:59:26,630 --> 00:59:28,463
the stack of cards.
导航控制器里的 segue 

1297
00:59:28,531 --> 00:59:31,199
Now when you do that, you get the back button for
当你进入新的 MVC之后，你就得到了一个

1298
00:59:31,268 --> 00:59:33,134
free, it just automatically appears up there because
返回按钮，它会自动生成在那里，因为

1299
00:59:33,203 --> 00:59:35,036
that top bar like I say is
那个顶部的栏就像我说的

1300
00:59:35,105 --> 00:59:38,740
drawn by the navigation controller's part of its view.
是由导航控制器的一部分的视图画的

1301
00:59:38,809 --> 00:59:41,409
And when you click that back button,
当你点击那个返回按钮时

1302
00:59:41,478 --> 00:59:43,745
of course what happens is interesting here.
当然这里发生的会很有趣

1303
00:59:43,814 --> 00:59:47,883
Of course this slides back, but what happened to that MVC?
当然了这会滑回去，但是刚刚那个显示的 MVC 发生了什么呢？

1304
00:59:47,952 --> 00:59:49,717
Gone.
消失了

1305
00:59:49,786 --> 00:59:52,054
Deallocated from the heap.
从堆中释放了

1306
00:59:53,089 --> 00:59:55,023
So when you go back,
所以当你返回的时候

1307
00:59:55,092 --> 00:59:58,526
whatever card was on top gets thrown away.
无论在顶层的是哪一个卡片，都会被扔掉

1308
00:59:58,595 --> 01:00:01,696
So MVCs, as you're kind of getting the picture here,
所以 MVC 们，就像你在这些图片上看到的

1309
01:00:01,765 --> 01:00:03,464
they're pretty ephemeral.
它们的生命周期很短暂

1310
01:00:03,533 --> 01:00:05,901
MVCs don't really stick around for a long time.
MVC 事实上不会长时间存在

1311
01:00:05,969 --> 01:00:07,502
Now the root card on a Navigation Controller,
那个在导航控制器上的根卡片

1312
01:00:07,571 --> 01:00:08,704
it's gonna stick around pretty long,
它存在的时间将会比较久

1313
01:00:08,772 --> 01:00:11,439
as long as that Navigation Controller is on screen.
只要这个导航控制器在屏幕上

1314
01:00:11,508 --> 01:00:14,108
But mostly MVCs kind of come and go.
但是大多数 MVC 来去匆匆

1315
01:00:14,177 --> 01:00:17,445
And it's their models that tend to be persistent.
只有它们的模型是不变的

1316
01:00:17,514 --> 01:00:18,379
When you create a new MVC,
当你创建一个新的 MVC 时

1317
01:00:18,448 --> 01:00:20,715
you usually hook it up to a database or a network or
你通常把它跟数据库或者网络或者

1318
01:00:20,784 --> 01:00:22,184
something, something persistent.
别的什么不变的东西连接

1319
01:00:22,252 --> 01:00:24,452
And so that's why it's showing something new.
这就是它为什么会显示新的东西的原因

1320
01:00:24,521 --> 01:00:27,189
Or it's an MVC that showed something new every time.
或者这是个每次显示新的东西的 MVC 

1321
01:00:28,758 --> 01:00:31,627
So that's how a navigation controller works.
这就是导航控制器工作原理了

1322
01:00:34,797 --> 01:00:36,397
I'm gonna talk a little bit how we hook all of this up.
我打算谈一下它们是如何连接的

1323
01:00:36,466 --> 01:00:38,333
Because of course we're gonna do all this hooking up with
因为当然了我们是通过在 Xcode 里拖拉

1324
01:00:38,401 --> 01:00:42,104
control drag in Xcode, that's how we hook everything up.
来实现这些所有的连接，通过这些连接让所有东西都可达

1325
01:00:42,172 --> 01:00:43,938
But I wanna talk a little bit about the code
但是我想谈一些背后的代码

1326
01:00:44,007 --> 01:00:44,806
behind so you know.
你们知道的

1327
01:00:44,875 --> 01:00:48,310
There's an important var that is in these viewControllers,
在这些 viewController 中有一个非常重要的变量

1328
01:00:48,379 --> 01:00:49,277
like tab bar controller, and
比如说标签栏控制器和

1329
01:00:49,346 --> 01:00:50,912
navigation controller, and split view controller.
导航控制器还有分屏控制器

1330
01:00:50,981 --> 01:00:52,547
It's called viewControllers, and
这个变量叫做 viewControllers，而且

1331
01:00:52,615 --> 01:00:56,017
it's an optional array of UIViewControllers.
它是一个可选类型的 UIViewController 数组

1332
01:00:56,086 --> 01:00:57,318
And it means different things depending on
这意味着里面有不同的数据

1333
01:00:57,387 --> 01:00:58,457
which one you're in.
取决于你在哪一个 UIViewController 里

1334
01:00:59,125 --> 01:01:03,194
so for example, in the tab bar, this is all the MVCs for each tab, with 
那么举例来说，在标签栏中，所有的 MVC 各自对应一个标签 

1335
01:01:03,363 --> 01:01:09,032
the left most tab's MVC's at 0 and then 1, 2, 3, 4 is just the 
最左边的 MVC 在 0 号位然后接下来就是 1 号，2 号，3 号，4 号

1336
01:01:09,201 --> 01:01:14,001
rest of the MVCs. For a split view 0 is always the master, 1 is always
也就是剩下的 MVC。对于 UISplitViewController 来说，0 号位通常都是主控制器

1337
01:01:14,070 --> 01:01:16,905
the detail, and there's never any other ones in this array.
1 号位通常是细节控制器，然后在数组中就没有别的了

1338
01:01:16,974 --> 01:01:21,743
For a navigation control, 0 is the base card, and 1, 2, 3,
对于导航控制器，0 号位是根卡片，然后就是 1，2，3，4 号

1339
01:01:21,812 --> 01:01:25,513
4, etc., are the ones stacked on top, in order.
之类的依次叠在顶上的卡片

1340
01:01:25,582 --> 01:01:27,315
So that's how you can kinda get at them.
所以这就是你得到这些控制器的方法

1341
01:01:27,383 --> 01:01:32,520
Now, we don't usually, this is a var, it can be set but
我们通常不会，这虽然是个变量，它可以被设置但是

1342
01:01:32,589 --> 01:01:35,623
we usually don't set this var, we don't set the things,
我们通常不会设置这个变量，我们不设置这些

1343
01:01:35,692 --> 01:01:38,993
we either use things that we do in our UI, which I'll show
而是在 UI 界面中使用这些东西，我会展示给你们

1344
01:01:39,062 --> 01:01:41,629
you or even like in Navigation Controller, there's push and
或者甚至比如说导航控制器里，有 push 和 pop 两个方法来

1345
01:01:41,698 --> 01:01:45,934
pop methods to push MVCs on and pop them off of the stack.
push MVC 到栈里或者把它们从栈中 pop 出来

1346
01:01:47,537 --> 01:01:51,272
Now, it's great to have this var ViewControllers, but
有这个叫做 viewControllers 的变量很方便，但是

1347
01:01:51,341 --> 01:01:53,642
how do you get the Split View Controller or
如果你在一个分屏控制器或者一个标签栏控制器里的话

1348
01:01:53,710 --> 01:01:56,477
get the Tab Bar Controller if you're in one?
你如何得到它们呢？

1349
01:01:56,546 --> 01:01:59,380
Okay if I'm the all settings MVC or
假设我是一个之前幻灯片里的那个所有设置 MVC 或者

1350
01:01:59,449 --> 01:02:04,052
I'm one of the health data ones that we saw on the tab
标签栏中看到的其中一个 Health Data

1351
01:02:04,121 --> 01:02:06,687
bar, how do I get the navigation controller I'm in,
我怎么得到我在的那个导航控制器

1352
01:02:06,756 --> 01:02:08,823
or the split view I'm in or the tab bar I'm in?
或者那个分屏控制器又或者那个标签栏控制器呢？

1353
01:02:08,892 --> 01:02:11,826
Well all UIViewControllers have these three vars,
所有的 UIViewController 都有这三个变量

1354
01:02:11,895 --> 01:02:13,461
tab bar controller, split view controller and
tabBarController，splitViewController 和

1355
01:02:13,529 --> 01:02:14,528
navigation controller.
navigationController

1356
01:02:14,597 --> 01:02:17,231
And if you are in one of those things this will return
而且如果你在它们其中一个里面的话它就会

1357
01:02:17,300 --> 01:02:18,867
the one you are in.
返回对应的那一个控制器

1358
01:02:18,936 --> 01:02:21,702
And if you're not in one, it will return nil.
如果你不在里面的话，它就会返回 nil 

1359
01:02:21,771 --> 01:02:22,604
So that's how you find out
这就是如何获取

1360
01:02:22,673 --> 01:02:24,039
the Split View Controller you're in.
丹铅你所在的分屏控制器的方法了

1361
01:02:24,107 --> 01:02:25,581
And you can use the combination of
而且你可以组合使用

1362
01:02:25,742 --> 01:02:25,999
these two things.
这两个东西

1363
01:02:26,009 --> 01:02:28,141
For example, if you're the Master in a Split View,
例如，你是一个分屏控制器里的主控制器

1364
01:02:28,344 --> 01:02:31,513
you can find your detail MVC by saying
你可以找到你的细节 MVC 通过询问

1365
01:02:31,582 --> 01:02:33,415
what's the split view controller I'm in?
我在的 UISplitViewController 是什么？

1366
01:02:33,483 --> 01:02:36,017
Get its View Controllers, look at View Controller sub 1
拿到它里面的 viewControllers 变量，查询数组里的 1 号位

1367
01:02:36,086 --> 01:02:38,353
because that's always the detail.
因为 1 号位通常就是细节控制器

1368
01:02:38,502 --> 01:02:38,702
You see?
看到了吗？

1369
01:02:38,721 --> 01:02:40,171
So I just clicked and went up and over and got it.
所以我只是点击了下然后得到了它

1370
01:02:40,390 --> 01:02:43,058
And I use the question mark, the optional chaining there
并且我在那里使用了问号，也就是可选链

1371
01:02:43,126 --> 01:02:44,992
because I might not be in a split view controller.
因为我可能不在一个分屏控制器里

1372
01:02:45,061 --> 01:02:46,694
And then it obviously will return nil for
然后显而易见的它会对我的细节控制器结果返回 nil

1373
01:02:46,763 --> 01:02:49,864
my detail, which is fine cuz it would be nil if I'm not in
这个也没事因为如果我不是在一个分屏控制器里

1374
01:02:49,933 --> 01:02:51,666
a split view controller obviously there's no detail.
也就是没有细节控制器的话，结果的确会是 nil 

1375
01:02:54,237 --> 01:02:55,904
Now, how do we wire all this stuff up?
现在，我们如何把这些连在一起呢？

1376
01:02:55,972 --> 01:02:58,439
Of course we're gonna do it all graphically.
当然我们会通过图形的方法来做到这个

1377
01:02:58,508 --> 01:03:00,775
Let's start by at looking at the split view and
让我们从分屏控制器开始来

1378
01:03:00,843 --> 01:03:02,510
how we do this.
看看怎么做

1379
01:03:02,579 --> 01:03:05,279
Now to create a new view controller, whether it's one
为了创建一个新的视图控制器

1380
01:03:05,348 --> 01:03:07,215
of these view controllers of view controllers that we
无论它是我们之前谈论过的视图控制器里的一种

1381
01:03:07,284 --> 01:03:09,517
were talking about or just a regular view controller.
还是仅仅只是一个正常普通的视图控制器

1382
01:03:09,586 --> 01:03:12,186
You go down to the object pallet and you drag it out
你在对象库里往下滑，然后

1383
01:03:12,255 --> 01:03:15,456
into your storyboard just like a button, except you're just
把它拖到你的 storyboard 中，就像一个按钮那样，只是

1384
01:03:15,525 --> 01:03:17,825
dragging to open space and it's created there.
你把它拖到了 storyboard 中空白的地方然后在那里创建它

1385
01:03:17,894 --> 01:03:20,562
Now when you drag a split view controller out, it's
当你拖出一个分屏控制器时

1386
01:03:20,630 --> 01:03:24,666
actually gonna drag out kind of empty, detail and master.
它事实上是拖拉出了一堆空白的细节和主控制器

1387
01:03:25,602 --> 01:03:26,467
You never want that.
你不会想要这样的

1388
01:03:26,536 --> 01:03:28,236
I don't know why it really does that.
我不知道为什么它会这样子

1389
01:03:28,305 --> 01:03:29,737
Just delete those.
但是删除它们吧

1390
01:03:29,806 --> 01:03:31,839
You're obviously gonna have your MVC's like your
很明显你会有像是

1391
01:03:31,908 --> 01:03:34,208
calculator and your graphing view controller sitting in
计算器和图像视图控制器这样的 MVC 在你的

1392
01:03:34,277 --> 01:03:36,410
your storyboard and you're gonna drag the split view
storyboard 中，然后你就把分屏控制器

1393
01:03:36,479 --> 01:03:38,779
controller and you're gonna wire it up to those.
拖出来再把它们都连接起来

1394
01:03:38,848 --> 01:03:42,083
So you're gonna delete any of the extra junk that comes out.
你只要把多出来的垃圾都删掉就好了

1395
01:03:42,152 --> 01:03:45,319
Then you just Ctrl+drag like we do,
然后你只要像我一样按住 control 然后用鼠标拖拉

1396
01:03:45,388 --> 01:03:48,422
our favorite gesture in Interface Builder, is Ctrl+drag.
我们在 Interface Builder 里最喜欢的手势就是 control + 拖拽

1397
01:03:48,491 --> 01:03:50,992
We just Ctrl+drag from the split view controller
我们只要按住 control 然后从分屏控制器

1398
01:03:51,061 --> 01:03:53,194
to the master and to the detail, so I'll get up.
拖拉到主控制器还有细节控制器，然后就安排好了

1399
01:03:53,263 --> 01:03:55,263
So this is what that looks like.
那么这就是它看起来的样子

1400
01:03:55,332 --> 01:03:57,432
Here I've got split view controller on the left.
我已经在左边有了分屏控制器

1401
01:03:57,501 --> 01:03:59,767
I've got calculator view control on the top and
在顶端有计算器视图控制器

1402
01:03:59,836 --> 01:04:02,236
I've got a graphing view controller on the bottom.
我在底部还有绘制图像的控制器

1403
01:04:02,305 --> 01:04:03,370
So I'm just gonna control,
所以我按住 control 键

1404
01:04:03,439 --> 01:04:04,972
drag from the split view controllers,
从分屏控制器中拖拽

1405
01:04:05,041 --> 01:04:06,174
the calculator controller.
到计算器控制器

1406
01:04:06,243 --> 01:04:08,510
This little black window is gonna come up.
这个小的黑色窗口将会显示出来

1407
01:04:08,578 --> 01:04:12,914
I'm gonna choose master view controller from the list and
我将会从列表中选择 master view controller

1408
01:04:12,983 --> 01:04:16,951
that's gonna hook that one up top to my master.
那样会将其作为我的主视图控制器

1409
01:04:17,020 --> 01:04:20,155
Then, I'm gonna Ctrl+drag to the bottom one, the black
然后，我按住 control 并拖拽到底部，那个黑色的

1410
01:04:20,223 --> 01:04:22,924
window comes up I'm gonna choose Detail View Controller
窗口显示出来了，我选择 detail view controller

1411
01:04:22,993 --> 01:04:24,659
then it's gonna make that connection.
然后会让其连接为细节视图控制器

1412
01:04:25,829 --> 01:04:27,361
Okay, as simple as that.
完成了，就像之前那么简单

1413
01:04:27,430 --> 01:04:29,363
Now you've got the split view with master that's
现在你已经有了

1414
01:04:29,432 --> 01:04:31,566
calculator of your controller and
计算器控制器和

1415
01:04:31,635 --> 01:04:34,169
detail that is going to be a graphic view controller.
分屏显示的细节视图会是图像控制器

1416
01:04:35,405 --> 01:04:37,205
Now, one interesting thing here though,
这里有个有趣的事情

1417
01:04:37,274 --> 01:04:39,774
is this split view does not work on an iPhone.
这个分屏显示无法在 iPhone 上运行

1418
01:04:39,843 --> 01:04:43,344
Well it works on iPhone plus, iPhone six plus or
但能在 iPhone Plus 上运行，iPhone6 Plus 或

1419
01:04:43,413 --> 01:04:46,013
seven plus, the kind of big ones, but it does not work on
7 Plus，类似这种大屏幕的，但无法运行在

1420
01:04:46,082 --> 01:04:48,783
a normal iPhone, it's just not enough screen real estate to
小尺寸 iPhone 上，因为屏幕不够大

1421
01:04:48,851 --> 01:04:52,053
really do the split view thing, so we can't do it.
所以无法做分屏显示，所以我们没法做

1422
01:04:52,122 --> 01:04:54,989
So, what we really want to do is build a UI though that
那么，我们要做的是开发一个 UI 界面

1423
01:04:55,058 --> 01:04:56,191
works on all the devices.
能在所有尺寸设备上运行的

1424
01:04:56,259 --> 01:04:59,827
So to do that, what we do is we're gonna wrap
那么要想开发出来，我们需要

1425
01:04:59,896 --> 01:05:02,763
the master and the detail if we want.
把主视图和细节视图分别

1426
01:05:02,832 --> 01:05:05,466
We're gonna wrap them in a navigation controller.
嵌套到导航控制器里

1427
01:05:05,535 --> 01:05:06,901
And then when they're on iPhone,
当其运行在 iPhone 上的时候

1428
01:05:06,969 --> 01:05:08,102
they won't use the split view part,
程序无法使用分屏功能

1429
01:05:08,171 --> 01:05:09,838
they'll just use the navigation controller.
那时程序就只会用到导航控制器

1430
01:05:11,041 --> 01:05:13,808
It's really cool, how it figures this out.
这非常棒，我们解决了这个问题

1431
01:05:13,876 --> 01:05:17,178
The way to wrap a view controller that's in there,
嵌入视图控制器的方法在这

1432
01:05:17,246 --> 01:05:19,047
you wanna wrap it in a Navigation Controller,
你需要嵌套到导航控制器里

1433
01:05:19,116 --> 01:05:20,282
you just go to the Editor menu,
你只需要到编辑器菜单（Editor）

1434
01:05:20,350 --> 01:05:22,116
the same place we did embed and stack view,
在之前我们嵌入到 StackView 的地方

1435
01:05:22,185 --> 01:05:23,151
and some of that.
Embed in，一样一样

1436
01:05:23,220 --> 01:05:26,887
And you select the whole scene of your MVC, and
当你选择了整个 MVC 的场景时

1437
01:05:26,956 --> 01:05:29,623
you go to the Editor Menu and
你去到编辑器菜单

1438
01:05:29,692 --> 01:05:31,993
you say embed in navigation controller.
选择嵌入到导航控制器（Navigation Controller）

1439
01:05:32,062 --> 01:05:34,295
So I've selected that top, calculate and control and
也就是我选中顶端的计算器控制器

1440
01:05:34,363 --> 01:05:35,563
when I do that,
当我这样做时

1441
01:05:35,632 --> 01:05:38,199
it's going to put it inside a navigation controller.
它就会被放到一个导航控制器里

1442
01:05:38,268 --> 01:05:40,067
Did you see that?
你看到了吗？

1443
01:05:40,136 --> 01:05:42,236
Now, I've got the split view, it points to a navigation
现在，我有分屏视图了，它指向导航控制器

1444
01:05:42,305 --> 01:05:44,372
controller, so the master of this split view is actually
所以分屏控制器的主视图实际上

1445
01:05:44,441 --> 01:05:46,808
that navigation controller, and then the navigation
是个导航控制器，然后

1446
01:05:46,876 --> 01:05:50,311
controller root view controller is the calculator.
导航控制器的根视图是计算器

1447
01:05:50,379 --> 01:05:52,146
So, if you're on a device that can do split view,
所以，如果你在用一台能够分屏显示的设备

1448
01:05:52,215 --> 01:05:53,114
like an iPad or a plus,
比如 iPad 或者 iPhone Plus

1449
01:05:53,183 --> 01:05:55,316
you're going to get the whole split view effect.
你会获得完整的分屏显示效果

1450
01:05:55,385 --> 01:05:56,684
But if you're on just an iPhone,
但如果你在（小尺寸）iPhone 上运行

1451
01:05:56,753 --> 01:05:58,486
it's not going to do the split view.
其不能分屏显示

1452
01:05:58,555 --> 01:06:00,721
It's just going to do the navigation controller.
这时候就要用到导航控制器

1453
01:06:00,790 --> 01:06:01,989
So, when you look at the detail,
所以，你要查看细节视图

1454
01:06:02,058 --> 01:06:04,192
it's going to slide it in.
细节视图会滑进来覆盖主视图

1455
01:06:04,261 --> 01:06:06,761
Whereas if you're on a iPad in landscape,
然而当你在 iPad 上时

1456
01:06:06,830 --> 01:06:09,764
you're gonna see Master and Detail at the same time.
你会同时看到主界面和细节视图

1457
01:06:09,833 --> 01:06:13,568
Now, you can also do the same thing- yeah, and so
现在，你也可以做同样的事情了，等等

1458
01:06:13,637 --> 01:06:15,703
the UINavigationController is the Master,
导航控制器是主视图

1459
01:06:15,771 --> 01:06:17,639
as, as I talked about.
像我之前所说的

1460
01:06:17,707 --> 01:06:20,074
So you can do the same thing with the Detail.
你可以对细节视图中做同样的事

1461
01:06:20,143 --> 01:06:22,410
Now why would you ever do that with the Detail?
为什么要这样做呢？

1462
01:06:22,479 --> 01:06:24,111
Because yo've already done it with the master and
因为你已经嵌套了主视图

1463
01:06:24,180 --> 01:06:26,513
so you gotta click in the master to get to the detail,
你只需要点一下主视图来展示细节视图

1464
01:06:26,582 --> 01:06:28,516
so yo're kinda already gonna be in a navigation controller,
其实这就有点像导航控制器

1465
01:06:28,585 --> 01:06:29,584
and tha's true.
大实话

1466
01:06:29,653 --> 01:06:32,186
But wha's kinda nice about putting the detail
但我们可以把它变得更完美

1467
01:06:32,255 --> 01:06:35,223
in a navigation controller is you get that little title bar,
把细节视图嵌入导航控制器后会有标题栏

1468
01:06:35,292 --> 01:06:36,524
you know the little gray title bar?
就是那个灰色的小标题栏

1469
01:06:36,593 --> 01:06:37,391
So now, your master and
所以现在，你的主视图和

1470
01:06:37,460 --> 01:06:39,561
your detail both have a title bar on the top and
细节视图在屏幕顶端都有标题栏

1471
01:06:39,629 --> 01:06:40,961
they match up nicely.
他们看上去更加相匹配了

1472
01:06:41,030 --> 01:06:42,930
So if you wanna title on your detail,
如果你想在你的细节视图上有个标题

1473
01:06:42,999 --> 01:06:43,598
that's a good thing to do.
这是个好方法

1474
01:06:43,666 --> 01:06:45,566
The only thing to be careful there though is
唯一需要注意的事情是

1475
01:06:45,635 --> 01:06:48,269
now your detail in not a graph view controller.
细节视图控制器不是图形视图控制器

1476
01:06:48,338 --> 01:06:50,638
Your detail is now a navigation controller.
你的细节视图现在是一个导航控制器

1477
01:06:50,706 --> 01:06:52,540
So if you wanna get the graph view controller and
如果你想访问图形视图控制器

1478
01:06:52,609 --> 01:06:54,342
like talk to it, tell it what to graph or
像之前说的那样，告诉它什么需要绘制之类的

1479
01:06:54,410 --> 01:06:56,911
something like that, you need to get the root view
你需要间接通过

1480
01:06:56,980 --> 01:06:58,580
controller of the navigation controller.
导航控制器中的根视图控制器

1481
01:06:59,982 --> 01:07:01,549
So it's just subtle difference but
这有一点微妙的变化但

1482
01:07:01,617 --> 01:07:03,685
if you wrap your detail in a navigation controller,
如果你用导航控制器嵌套细节视图控制器

1483
01:07:03,753 --> 01:07:05,853
the detail has come become a navigation controller.
那么细节视图就变成了一个导航控制器

1484
01:07:05,922 --> 01:07:07,588
It's easy to get to the graph view controller,
获取图形视图控制器非常简单

1485
01:07:07,657 --> 01:07:09,724
cuz the root view controller of the navigation controller.
因为有了在导航控制器里的根视图控制器

1486
01:07:12,095 --> 01:07:15,096
That's how you wire up the split views so
这就是你如何让分屏视图

1487
01:07:15,165 --> 01:07:17,298
that it works cross platform, all devices.
适应所有操作平台和设备

1488
01:07:18,568 --> 01:07:21,302
The last thing we're gonna talk about is segueing.
今天最后一件我们要讨论的事情是关于转场功能

1489
01:07:21,370 --> 01:07:25,406
So we know how to wire up the split view controller, and
那么我们已经知道如何使用分屏控制器，并且

1490
01:07:25,475 --> 01:07:26,974
we know how to do a navigation control,
我们还知道如何使用导航控制

1491
01:07:27,043 --> 01:07:29,376
we just embed it in the navigation controller.
我们把它嵌入到导航控制器中

1492
01:07:29,445 --> 01:07:31,346
I didn't talk about the tab bar controller by the way,
顺便说一句我之前并没有说过标签栏控制器

1493
01:07:31,414 --> 01:07:32,446
but that's easy.
但那很简单

1494
01:07:32,515 --> 01:07:35,450
You just drag a tab bar controller out and CTRL + drag
只要拖拽出一个标签栏控制器，按住 control

1495
01:07:35,518 --> 01:07:38,152
to all of the MVC's that you want it to show,
然后拖拽到所有你希望显示出的 MVC 中

1496
01:07:38,221 --> 01:07:42,223
and you can actually even drag the little icons around
而且实际上你还可以拖拽一个小图标并

1497
01:07:42,291 --> 01:07:43,724
to put them in order.
使他们有序的排列开来

1498
01:07:43,793 --> 01:07:46,227
You can even set the icons in text in the interface builder
甚至你可以在 Interface Builder 中调整图标和标题

1499
01:07:46,296 --> 01:07:46,961
with an inspector.
通过检查工具

1500
01:07:47,029 --> 01:07:49,797
So, tab bars, so simple I don't even want to waste time
标签栏太简单，我并不想花太多时间

1501
01:07:49,866 --> 01:07:52,633
showing it, but so we know how to kind of hook up and control
我们现在知道如何用 control 拖拽连接

1502
01:07:52,702 --> 01:07:56,971
drags and wire up, or embed to do the navigation controllers.
还知道如何嵌入到导航控制器中

1503
01:07:57,040 --> 01:07:59,540
How do we go from one to the other, like in the navigation
我们如何从一个跳转到另外一个呢，像在导航控制器内

1504
01:07:59,609 --> 01:08:02,109
controller, how do we go from all settings to settings and
我们如何在设置应用中跳转到通用设置

1505
01:08:02,178 --> 01:08:03,244
from settings to accessibility,
从通用设置到辅助功能

1506
01:08:03,312 --> 01:08:07,081
and accessibility to larger text?
然后从辅助功能到更大字体呢？

1507
01:08:07,149 --> 01:08:09,651
How do we set up that transition or how do we make
我们如何设置其转场，或者说我们如何能做到

1508
01:08:09,719 --> 01:08:13,354
it so that we press a button in our calculator split view
当我们在分屏显示的计算器中按下一个按钮

1509
01:08:13,423 --> 01:08:16,557
and it causes that graph to be replaced with a new graph?
会使新画面替换掉旧画面呢？

1510
01:08:16,626 --> 01:08:17,157
How do we do that?
到底如何实现呢？

1511
01:08:17,226 --> 01:08:19,226
We do that with what are called segues.
我们要做的我们称之为 Segue（转场）

1512
01:08:19,295 --> 01:08:20,628
I've alluded to this earlier.
之前我有暗示过

1513
01:08:23,032 --> 01:08:24,832
These are the kinds of segues that exist.
自带的转场有以下几种

1514
01:08:24,900 --> 01:08:26,066
There's a show segue.
最简单的 Show，展示

1515
01:08:26,135 --> 01:08:28,436
That means, if you're in a Navigation Controller,
那意味着，如果你在导航控制器中

1516
01:08:28,504 --> 01:08:29,537
slide a card on.
新页面会滑进来

1517
01:08:31,441 --> 01:08:32,740
There's Show Detail,
有 Show Detail, 显示细节视图

1518
01:08:32,809 --> 01:08:34,208
which if you're a Navigation Controller,
但如果你是一个导航控制器

1519
01:08:34,277 --> 01:08:36,044
still means slide a card on.
依然是滑进来新页面

1520
01:08:36,112 --> 01:08:37,578
But if you're inside a Split View,
但如果你在分屏显示的情况下

1521
01:08:37,647 --> 01:08:40,982
it means put this new MVC where the detail goes.
意味着需要将 MVC 作为细节视图显示

1522
01:08:41,051 --> 01:08:42,683
That's why it's called Show Detail.
这就是为什么叫做显示详情

1523
01:08:42,752 --> 01:08:44,552
So Show Detail behaves differently depending on
那么显示细节视图不同的行为取决于

1524
01:08:44,621 --> 01:08:45,653
whether you're in the Split View or
你是在分屏显示还是

1525
01:08:45,722 --> 01:08:48,122
whether you're in a Navigation Controller.
在导航控制器中

1526
01:08:48,191 --> 01:08:50,591
Modal segue, it's kind of interesting one.
模态框转场，这是个有趣的东西

1527
01:08:50,660 --> 01:08:53,227
It takes over the entire screen and lets
它会占用整个屏幕并让

1528
01:08:53,296 --> 01:08:57,831
the MVC that you're segueing into own the whole screen.
你过渡到的 MVC 占用整个屏幕

1529
01:08:57,900 --> 01:09:00,034
Now, these can be somewhat disturbing to the users cuz,
现在，这些东西会让使用者感到厌烦

1530
01:09:00,103 --> 01:09:01,869
I can't get back to where I was,
“我无法回到我之前所操作的”

1531
01:09:01,938 --> 01:09:03,804
cuz there's no back button or anything.
因为没有返回键或其它的

1532
01:09:03,873 --> 01:09:05,239
That whatever MVC comes up and
那就是为什么出现的 MVC

1533
01:09:05,308 --> 01:09:07,775
takes over the screen has to provide some UI to get out of
要提供某种用户界面来退出全屏

1534
01:09:07,844 --> 01:09:10,945
there like cancel or done, or something.
比如取消或者完成（按钮），或者类似的

1535
01:09:11,013 --> 01:09:13,915
So we try to stay away from Modal if we can.
所以我们尽可能的远离模态框

1536
01:09:13,983 --> 01:09:18,019
So Popover is sort of the same as Modal, but
弹出框和模态框类似

1537
01:09:18,087 --> 01:09:20,621
instead of taking over the whole screen, it just puts up
但不会占用整个屏幕，只让其出现

1538
01:09:20,690 --> 01:09:22,656
a little pop-up window, a little popover window,
一个小弹窗，一个小的弹出框

1539
01:09:22,725 --> 01:09:24,958
you've seen that, on iPad especially.
你已经在 iPad 上见过了

1540
01:09:25,027 --> 01:09:28,229
It's still Modal, because if you click anywhere else,
它仍然是模态框，但如果你点击任何地方

1541
01:09:28,297 --> 01:09:29,797
the popover goes away.
这个弹窗就会消失

1542
01:09:29,866 --> 01:09:32,233
So it's essentially modal.
所以本质是它还是模态框

1543
01:09:32,302 --> 01:09:33,634
It's a little nicer than modal, though,
但它比模态框好一些

1544
01:09:33,703 --> 01:09:35,737
because you can really see the background kinda grayed out.
因为你可以看到背景变成灰色

1545
01:09:35,805 --> 01:09:37,772
And if you don't want what's in the popover,
如果你不需要弹出框内的信息

1546
01:09:37,840 --> 01:09:39,541
just click somewhere else and it goes away.
只需要点击任意其它位置它便会消失

1547
01:09:39,609 --> 01:09:42,076
So yeah, popover's a little nicer than modal.
所以是的，弹出框比模态框好些

1548
01:09:42,145 --> 01:09:44,078
But it only works on fairly large screens,
但其只在足够大的屏幕上工作

1549
01:09:44,147 --> 01:09:46,247
unless you have a really small pop over window.
除非你想有一个非常小的弹出框在屏幕上

1550
01:09:47,183 --> 01:09:51,319
Now, I'm going to emphasize for
现在，我要强调

1551
01:09:51,387 --> 01:09:54,421
the second time what I said before segues always create
第二次强调我之前说的转场总是会创建

1552
01:09:54,490 --> 01:09:56,824
a new instance of the MVC.
一个新的 MVC 实例去取代旧的

1553
01:09:56,893 --> 01:10:00,695
All of the segues, all of them, modal, popover, show,
所有的转场，模态框，弹出框，展示

1554
01:10:00,764 --> 01:10:01,495
slide them in,
把视图滑进来

1555
01:10:01,564 --> 01:10:04,265
show detail, even show detail in the split view.
显示详情，包括在分屏中显示详情

1556
01:10:04,334 --> 01:10:07,635
If you have a calculator and you say graph my function and
如果你有一个计算器，让它绘制我的函数

1557
01:10:07,704 --> 01:10:09,470
you segue to a graph view controller,
你要转场到一个图形视图控制器

1558
01:10:09,539 --> 01:10:11,372
it throws away the one that was there and
它会去掉正在显示的

1559
01:10:11,441 --> 01:10:14,908
puts a new one there, always creating new MVCs.
总是会创建新的 MVC 放在那儿

1560
01:10:14,977 --> 01:10:18,379
So think of these MVCs as ephemeral, they come alive,
所以想象这些短暂 MVC，它们被激活

1561
01:10:18,448 --> 01:10:20,280
they do their job and they go away.
它们完成了它们的工作然后就走了

1562
01:10:20,349 --> 01:10:23,784
They don't live you know, long lives.
它们不像你，能活那么久

1563
01:10:23,853 --> 01:10:25,686
Now the master and a split view.
现在主视图和分屏视图

1564
01:10:25,755 --> 01:10:27,121
The root view of a navigational,
导航的根视图

1565
01:10:27,190 --> 01:10:28,823
they tend to live fairly long.
它们能活很久

1566
01:10:28,891 --> 01:10:31,526
But even those, if that split view, if that navigational
但尽管那样，如果那个分屏视图，那个导航器

1567
01:10:31,594 --> 01:10:33,428
were to go off screen, they go away as well.
消失在屏幕上，它们也就走了

1568
01:10:35,698 --> 01:10:37,398
So how do we make these segues happen?
所以我们如何实现这些转场呢？

1569
01:10:37,467 --> 01:10:39,233
Of course, we use control drag.
当然是使用拖拽功能啦

1570
01:10:39,302 --> 01:10:41,569
We love to use control drag, so here for
我们喜欢用拖拽功能，所以这里

1571
01:10:41,637 --> 01:10:43,404
example is the calculator example.
举的例子是计算器的例子

1572
01:10:43,472 --> 01:10:44,672
I've got a split view.
我现在有了一个分屏视图

1573
01:10:44,740 --> 01:10:46,874
And in my calculator there in the upper right
在我的计算器的右上角

1574
01:10:46,943 --> 01:10:49,477
I have a button it's very hard to see but
我有一个非常难看到的按钮

1575
01:10:49,545 --> 01:10:51,111
it's a little picture of a graph.
那是个函数图像的图片

1576
01:10:51,180 --> 01:10:52,813
So that's the button that when I press it,
所以当我按下那个按钮时

1577
01:10:52,882 --> 01:10:55,549
it's gonna take whatever's in my calculator and graph it.
无论计算器是什么内容，图像视图都会绘制出来

1578
01:10:55,618 --> 01:10:59,019
So if I've typed in for example m cosine,
所以如果我输入比如余弦 m

1579
01:10:59,088 --> 01:11:04,258
it's gonna draw a cosine wave, that's what that button does.
它便会画一个余弦波，那就是按钮的功能

1580
01:11:04,327 --> 01:11:07,661
So I just go into interface builder here, control drag
那么我到 Interface Builder 这，按 control

1581
01:11:07,730 --> 01:11:10,564
from that button down to the detail right there.
拖拽按钮到右边细节视图那

1582
01:11:10,633 --> 01:11:11,532
When I let go,
当我放开鼠标

1583
01:11:11,601 --> 01:11:13,634
it's going to put up just a little black window,
会出现一个小的黑色窗口

1584
01:11:13,703 --> 01:11:15,502
which I'll show you a little detail of.
我会展示它具体长什么样

1585
01:11:15,571 --> 01:11:16,003
It looks like that.
就像那样

1586
01:11:16,072 --> 01:11:18,106
And I'm gonna pick the segue I want.
然后我要选择一个我想要的转场

1587
01:11:18,174 --> 01:11:21,675
Well, since this is a Split view, if I can,
那么，既然这是个分屏视图，如果我可以的话

1588
01:11:21,744 --> 01:11:23,177
I'm going to show detail.
我将要其显示详情

1589
01:11:23,245 --> 01:11:25,079
Put it on the right side of the split view.
将其放到分屏视图的右边

1590
01:11:25,148 --> 01:11:27,348
Now, if I were in this same storyboard, but
现在，如果我在这相同的 storyboard

1591
01:11:27,417 --> 01:11:29,583
I was on an iPhone non-plus,
但我当是在小尺寸的 iPhone 上

1592
01:11:29,652 --> 01:11:31,251
then even though I'm picking show detail here,
即使我选择显示详情，其仍然会

1593
01:11:31,320 --> 01:11:33,754
it's still going to do the navigation controller show,
在（小尺寸 iPhone 上）通过导航控制器呈现

1594
01:11:33,823 --> 01:11:36,291
because there is no split view side, when I'm on the iPhone.
因为在小尺寸的 iPhone 上没有办法分屏显示

1595
01:11:37,760 --> 01:11:39,894
So I pick the segue type I want, and
所以我选择一个我想要的转场类型

1596
01:11:39,962 --> 01:11:41,229
it creates the segue.
Xcode 会创建 segue 实现转场效果

1597
01:11:41,297 --> 01:11:43,564
And it appears in your storyboard,
然后它会出现在你的 storyboard

1598
01:11:43,633 --> 01:11:45,232
it can even be clicked on and inspected.
其依然可以被点击并检查

1599
01:11:45,301 --> 01:11:47,467
And in fact you're gonna always want to click on
且事实上你总会想要去点击

1600
01:11:47,536 --> 01:11:49,170
that thing and inspect it.
并检查它

1601
01:11:49,239 --> 01:11:52,173
Cuz you gonna wanna set this thing right here which
因为你会想要设置这里的

1602
01:11:52,242 --> 01:11:53,841
is the identifier.
identifier，标识符

1603
01:11:53,910 --> 01:11:56,677
Every segue has an identifier, it's just the string and
每一个转场都有一个标识符，这只是一个字符串

1604
01:11:56,745 --> 01:12:00,013
that identifier is what's you're gonna use in your code
这个标识符是你在代码中

1605
01:12:00,082 --> 01:12:02,649
to talk about this segue.
用来与转场进行互动的

1606
01:12:02,718 --> 01:12:04,252
And I'll talk about what you
等会儿我要谈到的是

1607
01:12:04,320 --> 01:12:07,120
can talk about regarding segues in a moment here.
你们需要用转场 segue 做什么

1608
01:12:07,189 --> 01:12:08,389
So always set that.
总之你总是需要设置它

1609
01:12:08,457 --> 01:12:09,223
And you wanna set it,
而且你会想要设置一个

1610
01:12:09,291 --> 01:12:12,059
the identifier to be something that kind of says what is
不言而喻的标识符

1611
01:12:12,128 --> 01:12:12,660
segue does.
说明转场的作用是什么

1612
01:12:12,729 --> 01:12:14,995
So in this case it shows a graph, so
这种情况它是展示了一个图像

1613
01:12:15,064 --> 01:12:16,764
I call this show graph.
那么我称之为 Show Graph

1614
01:12:19,802 --> 01:12:22,236
That's how you set up your segue.
这就是你如何设置转场效果

1615
01:12:22,304 --> 01:12:24,204
And that's true for navigation controller as well.
同样也适用于导航控制器

1616
01:12:24,273 --> 01:12:25,673
If you have a navigation controller and
如果你有一个导航控制器且

1617
01:12:25,742 --> 01:12:28,209
you have a button that causes another card to slide on you
你有一个按钮让另一个页面滑进来

1618
01:12:28,278 --> 01:12:30,445
just control drag from that button to the other MVC.
只需按住 control 后从按钮拖拽到其它 MVC

1619
01:12:30,513 --> 01:12:33,915
And then you use a show segue, and it'll just work.
接着选择用 Show 转场展示，这样就完成了

1620
01:12:33,983 --> 01:12:35,049
Has to be all inside,
不过必须要在导航控制器里面

1621
01:12:35,117 --> 01:12:37,751
embedded in navigation controller, of course.
当然嵌套到导航控制器才行

1622
01:12:37,820 --> 01:12:39,720
So what can you do with these identifiers?
所以你可以用这些标识符来做什么呢？

1623
01:12:39,789 --> 01:12:42,457
It is actually possible to cause a segue to happen from
其实代码能用这个标识符实现转场

1624
01:12:42,525 --> 01:12:45,425
code, with performSegue withIdentifier, but
使用的是 performSegue(withIdentifier:) 方法

1625
01:12:45,494 --> 01:12:47,961
I'm not gonna talk about that, cuz we're never gonna do that.
我并不打算讨论那些，因为我们永远也不会用到

1626
01:12:48,030 --> 01:12:49,329
We always gonna have buttons,
我们总是会通过按钮实现

1627
01:12:49,398 --> 01:12:50,764
well I'm not gonna say we're never gonna do that,
好吧我不应该说我们永远也不会用到

1628
01:12:50,833 --> 01:12:52,767
but we won't be doing that in your assignment three,
但我们在作业三中还暂时不会用到

1629
01:12:52,835 --> 01:12:53,267
that's for sure.
这是肯定的

1630
01:12:53,336 --> 01:12:54,301
It's pretty rare.
很少会这样做

1631
01:12:54,370 --> 01:12:56,303
But you can do it with performSegue.
但你可以通过 performSegue 实现

1632
01:12:56,372 --> 01:12:59,006
But the more important use of the identifier is not causing
标识符最重要的用法不是实现转场

1633
01:12:59,075 --> 01:13:00,774
segues to happen cuz segues kinda happen
因为转场效果的实现是

1634
01:13:00,843 --> 01:13:02,643
automatically when the buttons are pressed.
当按下按钮时自动实现的

1635
01:13:02,712 --> 01:13:04,645
It's to prepare for a segue.
它的目的是为转场做准备

1636
01:13:04,714 --> 01:13:08,148
This is the most important method in all of
prepare(for segue:) 是所有方法中

1637
01:13:08,217 --> 01:13:11,552
multiple MVC programming is this preparing for segue
实现多个 MVC 编程的最重要的方法

1638
01:13:11,620 --> 01:13:15,489
method which I'm gonna show you in a moment here, okay.
之后我将要在这向你们展示下

1639
01:13:15,558 --> 01:13:18,058
And remember, we're all segueing to a new MVC
别忘了，我们总是转场到新的 MVC

1640
01:13:18,127 --> 01:13:20,227
freshly created, so it's always raw.
全新的，未加处理的

1641
01:13:20,296 --> 01:13:22,830
So we have to prepare it to do what it's going to do.
所以我们需要让其准备好我们要做的

1642
01:13:24,734 --> 01:13:25,466
Here is the method.
方法这样写

1643
01:13:25,534 --> 01:13:27,334
It's called prepare for segue, and
prepare(for segue:), 准备转场

1644
01:13:27,403 --> 01:13:30,972
it also has a sender argument right there.
同时还有 sender 参数，表示发起转场的实例

1645
01:13:31,040 --> 01:13:34,375
The segue that's passed along that first argument
作为第一个参数的转场 segue

1646
01:13:34,444 --> 01:13:37,611
is just a little container that contains interesting
只是一个容器，其中包含了

1647
01:13:37,680 --> 01:13:39,613
information about the segue.
关于转场的信息

1648
01:13:39,682 --> 01:13:42,049
For example, the identifier, Show Graph.
例如标识符（这里是 "Show Graph"）

1649
01:13:43,585 --> 01:13:47,187
And very importantly, the controller that you're seguing
然后很重要的，转场到的目标控制器

1650
01:13:47,256 --> 01:13:48,455
too, because the whole point is here,
你为这个方法的作用

1651
01:13:48,524 --> 01:13:51,292
you're suppose to be preparing this MVC that's going to
就是让目标 MVC 准备好

1652
01:13:51,360 --> 01:13:52,593
come on screen.
出现在屏幕上

1653
01:13:52,661 --> 01:13:53,794
To do its job so
完成它的工作

1654
01:13:53,862 --> 01:13:57,431
you get that thing from this little segue object.
所以我们要从 segue 中得到目标控制器

1655
01:13:57,499 --> 01:14:00,301
The sender is kinda like buttons,
sender 就是像按钮一类的

1656
01:14:00,370 --> 01:14:02,636
the button sender when we had the action there.
我们按下去来转场的按钮

1657
01:14:02,705 --> 01:14:05,505
It's just what object is instigating this.
总之就是开始这个转场的对象

1658
01:14:05,574 --> 01:14:08,108
So in the calculator example you're gonna have a button
在计算器中，我们有个按钮

1659
01:14:08,177 --> 01:14:11,044
clicking causing this segue, it's gonna be that button.
按下之后就开始转场，所以 sender 是那个按钮

1660
01:14:11,113 --> 01:14:12,646
Okay, the button that's causing the segue.
那个造成转场的按钮

1661
01:14:12,715 --> 01:14:16,884
But it's Any because anything, when we saw the example
但它的类型是 Any，我们看到的例子

1662
01:14:16,952 --> 01:14:20,220
of the all settings, we were clicking on table view cells
所有设置中，我们点击的是 UITableViewCell

1663
01:14:20,289 --> 01:14:23,257
they are not buttons but cells in what's called a table view,
表格视图里没有按钮，只有一行行的 cell

1664
01:14:23,325 --> 01:14:25,692
which we're gonna talk about week after next.
我们再下下周讲

1665
01:14:25,761 --> 01:14:27,561
And so that could be the sender.
所以 UITableViewCell 能是 sender

1666
01:14:27,630 --> 01:14:30,364
Or you might have done perform segue on the previous slide,
又比如之前看到的 performSegue

1667
01:14:30,433 --> 01:14:32,066
that actually let you set the sender so
那个你是可以设置 sender 的

1668
01:14:32,134 --> 01:14:35,769
you've tell it anything you want, it could be nil also.
sender 可以是任何的实例 或 nil

1669
01:14:35,838 --> 01:14:36,971
We don't use it that much.
这个我们不是很常用

1670
01:14:38,307 --> 01:14:40,774
The first thing I'm
我做的第一件事

1671
01:14:40,843 --> 01:14:42,242
do is going to be get the identifier.
是通过 identifier 得到标识符

1672
01:14:42,311 --> 01:14:43,477
Note that it can be nil so
注意因为可能是 nil

1673
01:14:43,546 --> 01:14:47,447
I'm gonna say if let to get it out of that segue right there.
所以用的是 if-let 来从 segue 获得标识符

1674
01:14:47,516 --> 01:14:49,950
And I need that identifier cuz I need to know which segue I'm
我需要用这个 identifier 来判断

1675
01:14:50,019 --> 01:14:52,486
doing because I might have three buttons
究竟是哪个转场，因为我可能有三个按钮

1676
01:14:52,555 --> 01:14:55,355
on my calculator that segued to three different things.
我的计算器会转场到不同的地方

1677
01:14:55,424 --> 01:14:57,424
Now you're not gonna have in assignment three but you could
虽然在作业三里不会有这个

1678
01:14:57,493 --> 01:14:59,192
have multiple buttons segueing to different things.
但是你可以让不同的按钮转场到不同的控制器

1679
01:14:59,261 --> 01:15:02,062
So you need to know which segue you're talking about.
所以我们要知道这个 segue 究竟是哪一个

1680
01:15:02,131 --> 01:15:05,032
So you switch on it and then you check the case.
我们用 switch 判断究竟是哪个 case

1681
01:15:05,101 --> 01:15:07,301
And in the case of Show Graph,
如果是 "Show Graph" 的情况

1682
01:15:07,370 --> 01:15:10,204
which is the one we're gonna do right here,
也就是我们要处理的这个

1683
01:15:10,272 --> 01:15:16,010
we're going to prepare that graphing MVC to do its job.
我们就把绘图的控制器准备好

1684
01:15:16,078 --> 01:15:20,314
Now, in order to talk to that graphing MVC,
为了能够调用它对应的方法

1685
01:15:20,383 --> 01:15:22,983
we have to get it as a graph controller.
我们需要把它转换为 GraphController

1686
01:15:23,052 --> 01:15:25,653
Now the type of that destination view controller
因为 destinationViewController

1687
01:15:25,722 --> 01:15:29,623
that's in the segue object is just UIViewController,
在 segue 里只是 UIViewController 类型的

1688
01:15:29,692 --> 01:15:32,626
it doesn't know that it's a graph view controller or
并不知道是 Graph 视图控制器

1689
01:15:32,695 --> 01:15:35,262
something like that it's just UIViewController.
其他的，或只是 UIViewController

1690
01:15:35,330 --> 01:15:37,064
So we have to use as,
所以为我们用 as 关键字

1691
01:15:37,133 --> 01:15:40,734
remember the "as?" I told you you could cast anything.
记得我说 as? 能够用来转换类型

1692
01:15:40,803 --> 01:15:44,438
Not just any object, you can cast a UIViewController to try
不只是转换 AnyObject，你可以尝试

1693
01:15:44,507 --> 01:15:47,007
and down cast it to a specific view controller.
把 UIViewController 向下转化为某个子类

1694
01:15:47,076 --> 01:15:49,910
So here I'm going to try and cast the destination view
这里我尝试把 destinationViewController

1695
01:15:49,979 --> 01:15:51,445
controller to be a graph controller.
转换为 GraphController

1696
01:15:51,514 --> 01:15:54,014
I'm gonna assume the graph controller is the type of
我们这里假设 GraphController

1697
01:15:54,083 --> 01:15:56,884
the controller of my graph MVC.
是我用来画图的控制器的类型

1698
01:15:56,953 --> 01:15:58,819
And if I'm able to do that, which I should be,
如果我能这么做的话，我确实也可以

1699
01:15:58,888 --> 01:16:01,555
because I know this is the show graph segue, so
因为我知道这是 "Show Graph" 转场

1700
01:16:01,623 --> 01:16:03,224
I better be, if,
我最好是能这样做的

1701
01:16:03,292 --> 01:16:05,959
if I'm not then probably I wanna raise an exception here.
如果不行的话，我或许应该抛出个异常

1702
01:16:06,028 --> 01:16:07,961
Because I'm really expecting to be able to do it.
因为我期待向下转换是可以完成的

1703
01:16:08,030 --> 01:16:10,364
Maybe I use as exclamation point right there instead of
我应该在这里用 as!（感叹号）

1704
01:16:10,432 --> 01:16:14,101
as question mark as it'd be bad if I was doing this and
而不是 as?（问号）的，因为如果我这么做

1705
01:16:14,169 --> 01:16:15,836
it wasn't actually graphcontroller.
而得不到 GraphController 是很不好的

1706
01:16:15,905 --> 01:16:17,505
But anyway, I get the GraphController so
无论怎么说，我得到了 GraphController

1707
01:16:17,573 --> 01:16:22,409
now vc, this variable vc is of type graphcontroller, so
现在这个 vc 变量是 GraphController 类型的

1708
01:16:22,478 --> 01:16:24,511
I can start setting vars in it,
我可以给它的变量赋值

1709
01:16:24,580 --> 01:16:27,948
calling methods, whatever I need to do to prepare that
调用它的方法，完成我需要做的来准备

1710
01:16:28,017 --> 01:16:30,417
graph controller to do its job.
让 GraphController 能完成它的工作

1711
01:16:30,486 --> 01:16:30,918
Now in the Calculator case,
我们这个控制器的例子

1712
01:16:30,987 --> 01:16:33,954
what I'm doing is I'm going to somehow have to
我将要做的是通过某种方法

1713
01:16:34,023 --> 01:16:36,390
set the model of the graph view control or
设置好 Graph 视图控制器的模型

1714
01:16:36,459 --> 01:16:39,260
something to show the graph I want.
或之类的来现实我想要的图形

1715
01:16:39,328 --> 01:16:41,095
Based on what 's in my calculator.
来反映我计算器里的内容

1716
01:16:41,164 --> 01:16:43,130
So, I'm preparing it to do what it does.
所以我们做好让它完成工作的准备

1717
01:16:43,198 --> 01:16:46,033
I'm pretty much never going to talk to this thing again.
之后我是没有机会访问这个控制器的了

1718
01:16:46,102 --> 01:16:49,803
So I'm gonna give it all the information it needs to do to
所以我把它所有需要的信息都给他

1719
01:16:49,872 --> 01:16:51,572
go to a job.
来完成他的工作

1720
01:16:51,641 --> 01:16:55,242
This is kind of one time set up and
所以需要一步到位

1721
01:16:55,311 --> 01:16:57,411
that's the way MVCs need to work through, object oriented.
这就是 MVC 的做法，面向对象

1722
01:16:57,480 --> 01:16:59,580
They get set up once and then they just live on their own,
设置好一次就需要自力更生了

1723
01:16:59,648 --> 01:17:00,414
they do their own job.
完成好自己的工作

1724
01:17:00,483 --> 01:17:03,384
They don't talk back to the person who brought them up or
不会再去和让它显示出来的控制器交谈

1725
01:17:03,452 --> 01:17:04,585
to anyone else.
也不会去问别的什么

1726
01:17:04,654 --> 01:17:05,453
They live on their own.
它们就靠自己活下去

1727
01:17:06,989 --> 01:17:09,923
So you can do anything you want to here, to try to do it.
你这里可以做任何想做的来完成准备

1728
01:17:09,992 --> 01:17:12,292
One thing to warn you here though and
不过这里你需要注意的是

1729
01:17:12,361 --> 01:17:14,295
half of you will trip over this.
你们之中的一半都会遇到

1730
01:17:14,363 --> 01:17:16,062
When you're doing this preparation
当你在准备

1731
01:17:16,131 --> 01:17:17,832
of that graph controller,
GraphController 的时候

1732
01:17:17,900 --> 01:17:22,269
that graph controller's outlets have not been set.
它的出口都还没有关连上

1733
01:17:24,140 --> 01:17:26,840
I told you that iOS hooks up those outlets to really really
虽然我说过 iOS 关连这些出口都很快

1734
01:17:26,909 --> 01:17:29,442
quickly, but this is one case where it doesn't quite hook
但这里是个例外

1735
01:17:29,511 --> 01:17:30,744
them up fast enough.
在这里就显得不够快了

1736
01:17:30,813 --> 01:17:34,414
When you're doing vc.property1 = whatever,
比如你设置 vc.某个属性 = 某个值

1737
01:17:34,483 --> 01:17:37,651
vc.callMethodToSetItUp, at that time,
或者这会儿调用 vc.某个方法()

1738
01:17:37,720 --> 01:17:39,953
none of vc's outlets are set.
vc 的出口都是 nil，没有关连上的

1739
01:17:40,022 --> 01:17:41,588
So you can't do anything in the UI.
所以你并不能做和 UI 相关的事

1740
01:17:41,657 --> 01:17:44,058
So if you're collecting information for what to,
所以如果你需要信息

1741
01:17:44,126 --> 01:17:44,859
to do in the UI,
来决定 UI

1742
01:17:44,927 --> 01:17:47,360
you're gonna have to store it in some vars or something.
你需要把它们存储到变量里

1743
01:17:47,429 --> 01:17:49,496
And then later, either in the did set
晚些时候，可以在

1744
01:17:49,565 --> 01:17:52,165
of those outlet setters, or I'm gonna teach you about view
在那些出口的 didSet 里，或者是…

1745
01:17:52,234 --> 01:17:53,701
controller life cycle next week.
我下周会讲视图控制器生命周期

1746
01:17:53,770 --> 01:17:55,669
There's other methods that happen later,
其他有些方法会在晚些时候被调用

1747
01:17:55,738 --> 01:17:58,438
that you can be sure that the outlets are set.
那是你可以确保所有的出口都关连好了

1748
01:17:58,507 --> 01:18:01,008
So this is in red, any time I put something with red inside,
所以这个我是用红色的字。任何时候我用红色

1749
01:18:01,077 --> 01:18:02,342
you really wanna pay attention.
你就需要多注意下了

1750
01:18:02,411 --> 01:18:04,778
So the outlets are not set in graph controller
所以 GraphController 里的出口是没有设置的

1751
01:18:04,847 --> 01:18:07,715
when you're preparing, the process of preparing.
在准备的时候要特别注意

1752
01:18:09,418 --> 01:18:11,652
You can also prevent a segue from happening,
你还能中止转场

1753
01:18:11,720 --> 01:18:14,454
let's say if the calculator and you try to hit graph and
比如说你按下了“画函数图像”

1754
01:18:14,523 --> 01:18:16,289
you're on the middle of a binary operation,
但你有个二元运算符还没输入完

1755
01:18:16,358 --> 01:18:17,624
pending binary operation.
有 pendingBinaryOperation

1756
01:18:17,693 --> 01:18:19,827
Well you can't graph that.
这个时候你是画不出来的

1757
01:18:19,896 --> 01:18:21,895
There's no way to graph a pending binary operation.
你不可能画不完整的二元运算

1758
01:18:21,964 --> 01:18:24,631
Three times, what's the graph of three times?
比如“三乘”，“三乘”这个怎么画？

1759
01:18:24,700 --> 01:18:25,532
It's nothing.
画不出来

1760
01:18:25,601 --> 01:18:27,001
So, you wanna prevent it.
所以你应该避免这种情况

1761
01:18:27,069 --> 01:18:29,202
So, in your assignment three you're gonna wanna use this
所以在作业三中你应该用这个方法

1762
01:18:29,271 --> 01:18:31,071
method in view controller should perform segue,
用控制器的 shouldPerformSegue

1763
01:18:31,140 --> 01:18:32,639
you're gonna return false.
让他返回 false

1764
01:18:32,708 --> 01:18:36,277
When you're in the middle of a pending operation, okay?
如果计算才到一半，那就这么做

1765
01:18:37,480 --> 01:18:39,780
And so that's it for today.
好，今天就讲到这里

1766
01:18:39,849 --> 01:18:41,381
There's no Friday section this week.
这周星期五没课

1767
01:18:41,450 --> 01:18:44,785
Next Friday section is going to be on performance analysis
下周五的会讲性能分析

1768
01:18:44,853 --> 01:18:46,453
cuz there's going to be an extra credit item
因为那可以帮你完成

1769
01:18:46,522 --> 01:18:48,255
in assignment three that does that.
我作业三里布置的加分题

1770
01:18:48,323 --> 01:18:49,923
You'll see that when it goes out.
之后布置作业的时候你们就知道了

1771
01:18:49,991 --> 01:18:50,824
Next week I'm gonna do
下周我会演示

1772
01:18:50,893 --> 01:18:52,892
a demo about all this multiple MVC stuff.
关于多个 MVC 的例子

1773
01:18:52,961 --> 01:18:55,195
I'm gonna start talking about the View Controller Lifecycle.
我会开始讲视图控制器生命周期

1774
01:18:55,264 --> 01:18:57,564
And then the super important topic, Protocols and
然后是非常重要的 protocol（协议）

1775
01:18:57,633 --> 01:19:02,436
Delegation.
和代理（delegate）

1776
01:19:02,504 --> 01:19:04,504
Strating doing more complicated UI things like scroll views and table views.
会讲更复杂的 UI，比如滚动视图和列表视图

1777
01:19:04,573 --> 01:19:07,341
We'll start that next week cuz all you're learning up till
我们下周开始讲这些，因为到现在为止

1778
01:19:07,410 --> 01:19:08,275
now is kinda the basics.
你们学的都只是基础

1779
01:19:08,343 --> 01:19:10,811
Swift and views and multiple MVCs.
Swift，视图 和多个 MVC

1780
01:19:10,879 --> 01:19:12,946
Once you got that basics in now you can start doing these
你学到了这些基础之后，就可以开始

1781
01:19:13,014 --> 01:19:14,715
more powerful objects.
使用这些更强大的对象

1782
01:19:14,784 --> 01:19:18,685
Now, assignment three is already on the class forums.
作业三已经放到课堂论坛 Piazza 上了

1783
01:19:18,754 --> 01:19:20,154
You can start it right now.
你现在已经可以开始做了

1784
01:19:20,223 --> 01:19:22,189
It's got really two major points to it.
其中最主要的两个重点

1785
01:19:22,257 --> 01:19:25,759
One is a custom UI view that does graphing.
一个是自定义的视图来画函数图像

1786
01:19:25,828 --> 01:19:28,461
A truly a custom MVC that does graphing.
一个自定义的 MVC 来画图

1787
01:19:28,530 --> 01:19:30,264
And that thing is completely independent of your
而且它是完全独立于

1788
01:19:30,333 --> 01:19:31,732
calculator.
你这个计算器的

1789
01:19:31,801 --> 01:19:33,867
In fact I would recommend you create a new app
其实我建议你新建一个工程

1790
01:19:33,936 --> 01:19:35,736
to create that MVC.
来完成那个 MVC

1791
01:19:35,805 --> 01:19:37,671
Because if you don't wanna be polluted by you calculator,
因为你是不希望被计算器影响

1792
01:19:37,739 --> 01:19:40,341
it's just a generic graphing MVC.
那应该是一个可以通用的绘图 MVC

1793
01:19:40,409 --> 01:19:41,275
Once you've got that,
当你完成之后

1794
01:19:41,343 --> 01:19:43,710
you're gonna combine it with your calculator
你再把它结合到计算器里

1795
01:19:43,779 --> 01:19:44,444
like I'm talking about here,
让后就像我说的那样

1796
01:19:44,513 --> 01:19:46,013
where you're going to click a button, and
按一个按钮

1797
01:19:46,082 --> 01:19:48,449
it's going to graph what's in your calculator.
然后显示计算器里的内容

1798
01:19:48,517 --> 01:19:50,517
So you can get started on that today because you already
你今天就可以开始这部分了

1799
01:19:50,585 --> 01:19:52,319
know everything you need to know about UI view and
因为你已经知道有关 UIView

1800
01:19:52,388 --> 01:19:53,654
doing a custom draw method.
和自定义 draw 方法了

1801
01:19:53,723 --> 01:19:55,422
So you could start drawing your graph and
所以你可以开始绘制你的图像

1802
01:19:55,490 --> 01:19:57,458
building that custom graphing view.
编写自定义的函数图像视图了

1803
01:19:57,526 --> 01:20:00,360
You could even build the custom MVC because you're
你还可以编程一个自定义 MVC

1804
01:20:00,429 --> 01:20:03,230
building it as a single MVC to start.
从一个单独的 MVC 开始写

1805
01:20:03,299 --> 01:20:05,533
But you're gonna wanna wait til Monday to try and
但我建议你等到下周一

1806
01:20:05,601 --> 01:20:07,334
hook it up to your calculator because you're
再尝试整合到计算器里，因为你

1807
01:20:07,402 --> 01:20:10,036
gonna wanna see me do the demo of a split view and
可以看到我演示使用分屏视图控制器

1808
01:20:10,105 --> 01:20:11,572
all that stuff and see that happening.
和其他的。实际看了这些

1809
01:20:11,641 --> 01:20:13,573
It'll help you when you start hooking your two
能帮助你整合

1810
01:20:13,642 --> 01:20:16,509
MVC's the graphing one and the calculator one together.
绘图的和计算器 MVC 到一起

1811
01:20:16,578 --> 01:20:18,278
And because you need next Monday
因为你需要下周一上课讲的内容

1812
01:20:18,347 --> 01:20:21,514
this assignment's not gonna be due until the next Monday.
所以下下周一再交

1813
01:20:21,583 --> 01:20:24,385
Okay, so you got a nice 10 or 11 days to get it done.
所以你们大概有个十天十一天来完成作业

1814
01:20:24,453 --> 01:20:27,054
But I strongly recommend you use the next few days to go
但我推荐你接着这几天的时间

1815
01:20:27,123 --> 01:20:29,056
ahead and get started on the view part of it.
先开始绘制视图的这部分

1816
01:20:29,124 --> 01:20:32,158
Because that's more than half of the assignment and
毕竟那占了这个作业的一半多

1817
01:20:32,227 --> 01:20:34,628
you can make a big head start into it.
因此你可以先完成很大的一部分

1818
01:20:34,696 --> 01:20:36,563
The last thing is the last reading assignment
最后是最后的阅读作业

1819
01:20:36,632 --> 01:20:37,631
also went out today.
昨天也布置了

1820
01:20:37,700 --> 01:20:40,334
The due date is pretty much next Wednesday.
下周三要完成

1821
01:20:41,470 --> 01:20:43,403
But that is going to make it so
但那也就意味着

1822
01:20:43,472 --> 01:20:45,338
you've read the entire Swift document.
你们已经阅读了整个 Swift 文档

1823
01:20:45,407 --> 01:20:47,107
So by the end of this assignment,
所以做完这个作业之后

1824
01:20:47,176 --> 01:20:49,443
you should feel like you know everything that's in there.
你应该掌握了里面所有的内容

1825
01:20:49,512 --> 01:20:51,145
Now of course, I don't expect you to know every
当然了，我并不会期望你知道

1826
01:20:51,214 --> 01:20:53,280
single detail about every single thing.
每一个知识点的每一个细节

1827
01:20:53,348 --> 01:20:54,681
But I expect you
但我希望你

1828
01:20:54,750 --> 01:20:57,317
if you like want to do a nested function I expect you
如果你想要写一个嵌套函数，我希望你

1829
01:20:57,386 --> 01:20:59,152
to be able to know where to go look to find that out.
至少知道在哪里能找到如何做

1830
01:20:59,221 --> 01:21:02,890
Or you wanna do optional chaining and
或者是你想要用可选链

1831
01:21:02,958 --> 01:21:05,592
you can't quite remember, you know where to go look it up.
但却记不清了，你应该知道在哪里找

1832
01:21:05,661 --> 01:21:06,660
That's a reference document.
The Swift Programming Language 是本手册

1833
01:21:06,728 --> 01:21:08,362
So you wanna know what's in there.
你应该要知道那里面都有些什么

1834
01:21:08,430 --> 01:21:11,632
Even if you don't memorize at all.
我就不强求你把所有的内容都记下来

1835
01:21:11,700 --> 01:21:12,699
That's it.
好，下课

1836
01:21:12,768 --> 01:21:14,201
See you next time.
下次课见

1837
01:21:14,270 --> 01:21:24,878
>> For more, please visit us at stanford.edu.
>> 更多课程详见 stanford.edu
